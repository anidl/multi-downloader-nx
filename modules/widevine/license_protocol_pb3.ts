// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file license_protocol.proto (package license_protocol, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from '@bufbuild/protobuf/codegenv1';
import { enumDesc, fileDesc, messageDesc } from '@bufbuild/protobuf/codegenv1';
import type { Message } from '@bufbuild/protobuf';

/**
 * Describes the file license_protocol.proto.
 */
export const file_license_protocol: GenFile =
	/*@__PURE__*/
	fileDesc(
		'ChZsaWNlbnNlX3Byb3RvY29sLnByb3RvEhBsaWNlbnNlX3Byb3RvY29sIq4CChVMaWNlbnNlSWRlbnRpZmljYXRpb24SFwoKcmVxdWVzdF9pZBgBIAEoDEgAiAEBEhcKCnNlc3Npb25faWQYAiABKAxIAYgBARIYCgtwdXJjaGFzZV9pZBgDIAEoDEgCiAEBEjAKBHR5cGUYBCABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSAOIAQESFAoHdmVyc2lvbhgFIAEoBUgEiAEBEiMKFnByb3ZpZGVyX3Nlc3Npb25fdG9rZW4YBiABKAxIBYgBAUINCgtfcmVxdWVzdF9pZEINCgtfc2Vzc2lvbl9pZEIOCgxfcHVyY2hhc2VfaWRCBwoFX3R5cGVCCgoIX3ZlcnNpb25CGQoXX3Byb3ZpZGVyX3Nlc3Npb25fdG9rZW4izCAKB0xpY2Vuc2USOAoCaWQYASABKAsyJy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VJZGVudGlmaWNhdGlvbkgAiAEBEjUKBnBvbGljeRgCIAEoCzIgLmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZS5Qb2xpY3lIAYgBARIzCgNrZXkYAyADKAsyJi5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyEh8KEmxpY2Vuc2Vfc3RhcnRfdGltZRgEIAEoA0gCiAEBEigKG3JlbW90ZV9hdHRlc3RhdGlvbl92ZXJpZmllZBgFIAEoCEgDiAEBEiIKFXByb3ZpZGVyX2NsaWVudF90b2tlbhgGIAEoDEgEiAEBEh4KEXByb3RlY3Rpb25fc2NoZW1lGAcgASgNSAWIAQESHAoPc3JtX3JlcXVpcmVtZW50GAggASgMSAaIAQESFwoKc3JtX3VwZGF0ZRgJIAEoDEgHiAEBElcKHHBsYXRmb3JtX3ZlcmlmaWNhdGlvbl9zdGF0dXMYCiABKA4yLC5saWNlbnNlX3Byb3RvY29sLlBsYXRmb3JtVmVyaWZpY2F0aW9uU3RhdHVzSAiIAQESEQoJZ3JvdXBfaWRzGAsgAygMGsoHCgZQb2xpY3kSFQoIY2FuX3BsYXkYASABKAhIAIgBARIYCgtjYW5fcGVyc2lzdBgCIAEoCEgBiAEBEhYKCWNhbl9yZW5ldxgDIAEoCEgCiAEBEiQKF3JlbnRhbF9kdXJhdGlvbl9zZWNvbmRzGAQgASgDSAOIAQESJgoZcGxheWJhY2tfZHVyYXRpb25fc2Vjb25kcxgFIAEoA0gEiAEBEiUKGGxpY2Vuc2VfZHVyYXRpb25fc2Vjb25kcxgGIAEoA0gFiAEBEi4KIXJlbmV3YWxfcmVjb3ZlcnlfZHVyYXRpb25fc2Vjb25kcxgHIAEoA0gGiAEBEh8KEnJlbmV3YWxfc2VydmVyX3VybBgIIAEoCUgHiAEBEiIKFXJlbmV3YWxfZGVsYXlfc2Vjb25kcxgJIAEoA0gIiAEBEisKHnJlbmV3YWxfcmV0cnlfaW50ZXJ2YWxfc2Vjb25kcxgKIAEoA0gJiAEBEh0KEHJlbmV3X3dpdGhfdXNhZ2UYCyABKAhICogBARIlChhhbHdheXNfaW5jbHVkZV9jbGllbnRfaWQYDCABKAhIC4gBARIsCh9wbGF5X3N0YXJ0X2dyYWNlX3BlcmlvZF9zZWNvbmRzGA0gASgDSAyIAQESKwoec29mdF9lbmZvcmNlX3BsYXliYWNrX2R1cmF0aW9uGA4gASgISA2IAQESKQocc29mdF9lbmZvcmNlX3JlbnRhbF9kdXJhdGlvbhgPIAEoCEgOiAEBQgsKCV9jYW5fcGxheUIOCgxfY2FuX3BlcnNpc3RCDAoKX2Nhbl9yZW5ld0IaChhfcmVudGFsX2R1cmF0aW9uX3NlY29uZHNCHAoaX3BsYXliYWNrX2R1cmF0aW9uX3NlY29uZHNCGwoZX2xpY2Vuc2VfZHVyYXRpb25fc2Vjb25kc0IkCiJfcmVuZXdhbF9yZWNvdmVyeV9kdXJhdGlvbl9zZWNvbmRzQhUKE19yZW5ld2FsX3NlcnZlcl91cmxCGAoWX3JlbmV3YWxfZGVsYXlfc2Vjb25kc0IhCh9fcmVuZXdhbF9yZXRyeV9pbnRlcnZhbF9zZWNvbmRzQhMKEV9yZW5ld193aXRoX3VzYWdlQhsKGV9hbHdheXNfaW5jbHVkZV9jbGllbnRfaWRCIgogX3BsYXlfc3RhcnRfZ3JhY2VfcGVyaW9kX3NlY29uZHNCIQofX3NvZnRfZW5mb3JjZV9wbGF5YmFja19kdXJhdGlvbkIfCh1fc29mdF9lbmZvcmNlX3JlbnRhbF9kdXJhdGlvbhreEwoMS2V5Q29udGFpbmVyEg8KAmlkGAEgASgMSACIAQESDwoCaXYYAiABKAxIAYgBARIQCgNrZXkYAyABKAxIAogBARJBCgR0eXBlGAQgASgOMi4ubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5LZXlUeXBlSAOIAQESSAoFbGV2ZWwYBSABKA4yNC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyLlNlY3VyaXR5TGV2ZWxIBIgBARJZChNyZXF1aXJlZF9wcm90ZWN0aW9uGAYgASgLMjcubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uSAWIAQESWgoUcmVxdWVzdGVkX3Byb3RlY3Rpb24YByABKAsyNy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91dHB1dFByb3RlY3Rpb25IBogBARJLCgtrZXlfY29udHJvbBgIIAEoCzIxLmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZS5LZXlDb250YWluZXIuS2V5Q29udHJvbEgHiAEBEnMKIG9wZXJhdG9yX3Nlc3Npb25fa2V5X3Blcm1pc3Npb25zGAkgASgLMkQubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PcGVyYXRvclNlc3Npb25LZXlQZXJtaXNzaW9uc0gIiAEBEmYKHHZpZGVvX3Jlc29sdXRpb25fY29uc3RyYWludHMYCiADKAsyQC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyLlZpZGVvUmVzb2x1dGlvbkNvbnN0cmFpbnQSJgoZYW50aV9yb2xsYmFja191c2FnZV90YWJsZRgLIAEoCEgJiAEBEhgKC3RyYWNrX2xhYmVsGAwgASgJSAqIAQEaWgoKS2V5Q29udHJvbBIeChFrZXlfY29udHJvbF9ibG9jaxgBIAEoDEgAiAEBEg8KAml2GAIgASgMSAGIAQFCFAoSX2tleV9jb250cm9sX2Jsb2NrQgUKA19pdhq7BQoQT3V0cHV0UHJvdGVjdGlvbhJPCgRoZGNwGAEgASgOMjwubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkhEQ1BIAIgBARJVCgpjZ21zX2ZsYWdzGAIgASgOMjwubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkNHTVNIAYgBARJfCg1oZGNwX3NybV9ydWxlGAMgASgOMkMubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkhkY3BTcm1SdWxlSAKIAQESIgoVZGlzYWJsZV9hbmFsb2dfb3V0cHV0GAQgASgISAOIAQESIwoWZGlzYWJsZV9kaWdpdGFsX291dHB1dBgFIAEoCEgEiAEBInkKBEhEQ1ASDQoJSERDUF9OT05FEAASCwoHSERDUF9WMRABEgsKB0hEQ1BfVjIQAhINCglIRENQX1YyXzEQAxINCglIRENQX1YyXzIQBBINCglIRENQX1YyXzMQBRIbChZIRENQX05PX0RJR0lUQUxfT1VUUFVUEP8BIkMKBENHTVMSDQoJQ09QWV9GUkVFEAASDQoJQ0dNU19OT05FECoSDQoJQ09QWV9PTkNFEAISDgoKQ09QWV9ORVZFUhADIjYKC0hkY3BTcm1SdWxlEhYKEkhEQ1BfU1JNX1JVTEVfTk9ORRAAEg8KC0NVUlJFTlRfU1JNEAFCBwoFX2hkY3BCDQoLX2NnbXNfZmxhZ3NCEAoOX2hkY3Bfc3JtX3J1bGVCGAoWX2Rpc2FibGVfYW5hbG9nX291dHB1dEIZChdfZGlzYWJsZV9kaWdpdGFsX291dHB1dBqKAgoZVmlkZW9SZXNvbHV0aW9uQ29uc3RyYWludBIiChVtaW5fcmVzb2x1dGlvbl9waXhlbHMYASABKA1IAIgBARIiChVtYXhfcmVzb2x1dGlvbl9waXhlbHMYAiABKA1IAYgBARJZChNyZXF1aXJlZF9wcm90ZWN0aW9uGAMgASgLMjcubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uSAKIAQFCGAoWX21pbl9yZXNvbHV0aW9uX3BpeGVsc0IYChZfbWF4X3Jlc29sdXRpb25fcGl4ZWxzQhYKFF9yZXF1aXJlZF9wcm90ZWN0aW9uGuMBCh1PcGVyYXRvclNlc3Npb25LZXlQZXJtaXNzaW9ucxIaCg1hbGxvd19lbmNyeXB0GAEgASgISACIAQESGgoNYWxsb3dfZGVjcnlwdBgCIAEoCEgBiAEBEhcKCmFsbG93X3NpZ24YAyABKAhIAogBARIjChZhbGxvd19zaWduYXR1cmVfdmVyaWZ5GAQgASgISAOIAQFCEAoOX2FsbG93X2VuY3J5cHRCEAoOX2FsbG93X2RlY3J5cHRCDQoLX2FsbG93X3NpZ25CGQoXX2FsbG93X3NpZ25hdHVyZV92ZXJpZnkihAEKB0tleVR5cGUSFgoSS0VZVFlQRV9VTlZFUklGSUVEEAASCwoHU0lHTklORxABEgsKB0NPTlRFTlQQAhIPCgtLRVlfQ09OVFJPTBADEhQKEE9QRVJBVE9SX1NFU1NJT04QBBIPCgtFTlRJVExFTUVOVBAFEg8KC09FTV9DT05URU5UEAYimAEKDVNlY3VyaXR5TGV2ZWwSHAoYU0VDVVJJVFlMRVZFTF9VTlZFUklGSUVEEAASFAoQU1dfU0VDVVJFX0NSWVBUTxABEhQKEFNXX1NFQ1VSRV9ERUNPREUQAhIUChBIV19TRUNVUkVfQ1JZUFRPEAMSFAoQSFdfU0VDVVJFX0RFQ09ERRAEEhEKDUhXX1NFQ1VSRV9BTEwQBUIFCgNfaWRCBQoDX2l2QgYKBF9rZXlCBwoFX3R5cGVCCAoGX2xldmVsQhYKFF9yZXF1aXJlZF9wcm90ZWN0aW9uQhcKFV9yZXF1ZXN0ZWRfcHJvdGVjdGlvbkIOCgxfa2V5X2NvbnRyb2xCIwohX29wZXJhdG9yX3Nlc3Npb25fa2V5X3Blcm1pc3Npb25zQhwKGl9hbnRpX3JvbGxiYWNrX3VzYWdlX3RhYmxlQg4KDF90cmFja19sYWJlbEIFCgNfaWRCCQoHX3BvbGljeUIVChNfbGljZW5zZV9zdGFydF90aW1lQh4KHF9yZW1vdGVfYXR0ZXN0YXRpb25fdmVyaWZpZWRCGAoWX3Byb3ZpZGVyX2NsaWVudF90b2tlbkIUChJfcHJvdGVjdGlvbl9zY2hlbWVCEgoQX3NybV9yZXF1aXJlbWVudEINCgtfc3JtX3VwZGF0ZUIfCh1fcGxhdGZvcm1fdmVyaWZpY2F0aW9uX3N0YXR1cyLAEAoOTGljZW5zZVJlcXVlc3QSPgoJY2xpZW50X2lkGAEgASgLMiYubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbkgAiAEBEk8KCmNvbnRlbnRfaWQYAiABKAsyNi5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbkgBiAEBEj8KBHR5cGUYAyABKA4yLC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LlJlcXVlc3RUeXBlSAKIAQESGQoMcmVxdWVzdF90aW1lGAQgASgDSAOIAQESKQoca2V5X2NvbnRyb2xfbm9uY2VfZGVwcmVjYXRlZBgFIAEoDEgEiAEBEkAKEHByb3RvY29sX3ZlcnNpb24YBiABKA4yIS5saWNlbnNlX3Byb3RvY29sLlByb3RvY29sVmVyc2lvbkgFiAEBEh4KEWtleV9jb250cm9sX25vbmNlGAcgASgNSAaIAQESUQoTZW5jcnlwdGVkX2NsaWVudF9pZBgIIAEoCzIvLmxpY2Vuc2VfcHJvdG9jb2wuRW5jcnlwdGVkQ2xpZW50SWRlbnRpZmljYXRpb25IB4gBARr3CgoVQ29udGVudElkZW50aWZpY2F0aW9uEmUKEndpZGV2aW5lX3Bzc2hfZGF0YRgBIAEoCzJHLmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZVJlcXVlc3QuQ29udGVudElkZW50aWZpY2F0aW9uLldpZGV2aW5lUHNzaERhdGFIABJXCgt3ZWJtX2tleV9pZBgCIAEoCzJALmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZVJlcXVlc3QuQ29udGVudElkZW50aWZpY2F0aW9uLldlYm1LZXlJZEgAEmIKEGV4aXN0aW5nX2xpY2Vuc2UYAyABKAsyRi5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5FeGlzdGluZ0xpY2Vuc2VIABJUCglpbml0X2RhdGEYBCABKAsyPy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5Jbml0RGF0YUgAGpgBChBXaWRldmluZVBzc2hEYXRhEhEKCXBzc2hfZGF0YRgBIAMoDBI4CgxsaWNlbnNlX3R5cGUYAiABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSACIAQESFwoKcmVxdWVzdF9pZBgDIAEoDEgBiAEBQg8KDV9saWNlbnNlX3R5cGVCDQoLX3JlcXVlc3RfaWQangEKCVdlYm1LZXlJZBITCgZoZWFkZXIYASABKAxIAIgBARI4CgxsaWNlbnNlX3R5cGUYAiABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSAGIAQESFwoKcmVxdWVzdF9pZBgDIAEoDEgCiAEBQgkKB19oZWFkZXJCDwoNX2xpY2Vuc2VfdHlwZUINCgtfcmVxdWVzdF9pZBqsAgoPRXhpc3RpbmdMaWNlbnNlEkAKCmxpY2Vuc2VfaWQYASABKAsyJy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VJZGVudGlmaWNhdGlvbkgAiAEBEiIKFXNlY29uZHNfc2luY2Vfc3RhcnRlZBgCIAEoA0gBiAEBEiYKGXNlY29uZHNfc2luY2VfbGFzdF9wbGF5ZWQYAyABKANIAogBARImChlzZXNzaW9uX3VzYWdlX3RhYmxlX2VudHJ5GAQgASgMSAOIAQFCDQoLX2xpY2Vuc2VfaWRCGAoWX3NlY29uZHNfc2luY2Vfc3RhcnRlZEIcChpfc2Vjb25kc19zaW5jZV9sYXN0X3BsYXllZEIcChpfc2Vzc2lvbl91c2FnZV90YWJsZV9lbnRyeRriAgoISW5pdERhdGESaQoOaW5pdF9kYXRhX3R5cGUYASABKA4yTC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5Jbml0RGF0YS5Jbml0RGF0YVR5cGVIAIgBARIWCglpbml0X2RhdGEYAiABKAxIAYgBARI4CgxsaWNlbnNlX3R5cGUYAyABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSAKIAQESFwoKcmVxdWVzdF9pZBgEIAEoDEgDiAEBIj8KDEluaXREYXRhVHlwZRIbChdJTklUREFUQVRZUEVfVU5WRVJJRklFRBAAEggKBENFTkMQARIICgRXRUJNEAJCEQoPX2luaXRfZGF0YV90eXBlQgwKCl9pbml0X2RhdGFCDwoNX2xpY2Vuc2VfdHlwZUINCgtfcmVxdWVzdF9pZEIUChJjb250ZW50X2lkX3ZhcmlhbnQiTAoLUmVxdWVzdFR5cGUSGgoWUkVRVUVTVFRZUEVfVU5WRVJJRklFRBAAEgcKA05FVxABEgsKB1JFTkVXQUwQAhILCgdSRUxFQVNFEANCDAoKX2NsaWVudF9pZEINCgtfY29udGVudF9pZEIHCgVfdHlwZUIPCg1fcmVxdWVzdF90aW1lQh8KHV9rZXlfY29udHJvbF9ub25jZV9kZXByZWNhdGVkQhMKEV9wcm90b2NvbF92ZXJzaW9uQhQKEl9rZXlfY29udHJvbF9ub25jZUIWChRfZW5jcnlwdGVkX2NsaWVudF9pZCKmAgoKTWV0cmljRGF0YRIXCgpzdGFnZV9uYW1lGAEgASgJSACIAQESOwoLbWV0cmljX2RhdGEYAiADKAsyJi5saWNlbnNlX3Byb3RvY29sLk1ldHJpY0RhdGEuVHlwZVZhbHVlGm4KCVR5cGVWYWx1ZRI6CgR0eXBlGAEgASgOMicubGljZW5zZV9wcm90b2NvbC5NZXRyaWNEYXRhLk1ldHJpY1R5cGVIAIgBARISCgV2YWx1ZRgCIAEoA0gBiAEBQgcKBV90eXBlQggKBl92YWx1ZSJDCgpNZXRyaWNUeXBlEhkKFU1FVFJJQ1RZUEVfVU5WRVJJRklFRBAAEgsKB0xBVEVOQ1kQARINCglUSU1FU1RBTVAQAkINCgtfc3RhZ2VfbmFtZSKJAQoLVmVyc2lvbkluZm8SIAoTbGljZW5zZV9zZGtfdmVyc2lvbhgBIAEoCUgAiAEBEiQKF2xpY2Vuc2Vfc2VydmljZV92ZXJzaW9uGAIgASgJSAGIAQFCFgoUX2xpY2Vuc2Vfc2RrX3ZlcnNpb25CGgoYX2xpY2Vuc2Vfc2VydmljZV92ZXJzaW9uIowHCg1TaWduZWRNZXNzYWdlEj4KBHR5cGUYASABKA4yKy5saWNlbnNlX3Byb3RvY29sLlNpZ25lZE1lc3NhZ2UuTWVzc2FnZVR5cGVIAIgBARIQCgNtc2cYAiABKAxIAYgBARIWCglzaWduYXR1cmUYAyABKAxIAogBARIYCgtzZXNzaW9uX2tleRgEIAEoDEgDiAEBEh8KEnJlbW90ZV9hdHRlc3RhdGlvbhgFIAEoDEgEiAEBEjEKC21ldHJpY19kYXRhGAYgAygLMhwubGljZW5zZV9wcm90b2NvbC5NZXRyaWNEYXRhEkAKFHNlcnZpY2VfdmVyc2lvbl9pbmZvGAcgASgLMh0ubGljZW5zZV9wcm90b2NvbC5WZXJzaW9uSW5mb0gFiAEBEk0KEHNlc3Npb25fa2V5X3R5cGUYCCABKA4yLi5saWNlbnNlX3Byb3RvY29sLlNpZ25lZE1lc3NhZ2UuU2Vzc2lvbktleVR5cGVIBogBARIjChZvZW1jcnlwdG9fY29yZV9tZXNzYWdlGAkgASgMSAeIAQEiiAIKC01lc3NhZ2VUeXBlEhoKFk1FU1NBR0VUWVBFX1VOVkVSSUZJRUQQABITCg9MSUNFTlNFX1JFUVVFU1QQARILCgdMSUNFTlNFEAISEgoORVJST1JfUkVTUE9OU0UQAxIfChtTRVJWSUNFX0NFUlRJRklDQVRFX1JFUVVFU1QQBBIXChNTRVJWSUNFX0NFUlRJRklDQVRFEAUSDwoLU1VCX0xJQ0VOU0UQBhIXChNDQVNfTElDRU5TRV9SRVFVRVNUEAcSDwoLQ0FTX0xJQ0VOU0UQCBIcChhFWFRFUk5BTF9MSUNFTlNFX1JFUVVFU1QQCRIUChBFWFRFUk5BTF9MSUNFTlNFEAoiUwoOU2Vzc2lvbktleVR5cGUSDQoJVU5ERUZJTkVEEAASEwoPV1JBUFBFRF9BRVNfS0VZEAESHQoZRVBIRVJNRVJBTF9FQ0NfUFVCTElDX0tFWRACQgcKBV90eXBlQgYKBF9tc2dCDAoKX3NpZ25hdHVyZUIOCgxfc2Vzc2lvbl9rZXlCFQoTX3JlbW90ZV9hdHRlc3RhdGlvbkIXChVfc2VydmljZV92ZXJzaW9uX2luZm9CEwoRX3Nlc3Npb25fa2V5X3R5cGVCGQoXX29lbWNyeXB0b19jb3JlX21lc3NhZ2UijxEKFENsaWVudElkZW50aWZpY2F0aW9uEkMKBHR5cGUYASABKA4yMC5saWNlbnNlX3Byb3RvY29sLkNsaWVudElkZW50aWZpY2F0aW9uLlRva2VuVHlwZUgAiAEBEhIKBXRva2VuGAIgASgMSAGIAQESRQoLY2xpZW50X2luZm8YAyADKAsyMC5saWNlbnNlX3Byb3RvY29sLkNsaWVudElkZW50aWZpY2F0aW9uLk5hbWVWYWx1ZRIiChVwcm92aWRlcl9jbGllbnRfdG9rZW4YBCABKAxIAogBARIcCg9saWNlbnNlX2NvdW50ZXIYBSABKA1IA4gBARJbChNjbGllbnRfY2FwYWJpbGl0aWVzGAYgASgLMjkubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXNIBIgBARIVCgh2bXBfZGF0YRgHIAEoDEgFiAEBElQKEmRldmljZV9jcmVkZW50aWFscxgIIAMoCzI4LmxpY2Vuc2VfcHJvdG9jb2wuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q3JlZGVudGlhbHMaRQoJTmFtZVZhbHVlEhEKBG5hbWUYASABKAlIAIgBARISCgV2YWx1ZRgCIAEoCUgBiAEBQgcKBV9uYW1lQggKBl92YWx1ZRqnCgoSQ2xpZW50Q2FwYWJpbGl0aWVzEhkKDGNsaWVudF90b2tlbhgBIAEoCEgAiAEBEhoKDXNlc3Npb25fdG9rZW4YAiABKAhIAYgBARIpChx2aWRlb19yZXNvbHV0aW9uX2NvbnN0cmFpbnRzGAMgASgISAKIAQESZAoQbWF4X2hkY3BfdmVyc2lvbhgEIAEoDjJFLmxpY2Vuc2VfcHJvdG9jb2wuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q2FwYWJpbGl0aWVzLkhkY3BWZXJzaW9uSAOIAQESIwoWb2VtX2NyeXB0b19hcGlfdmVyc2lvbhgFIAEoDUgEiAEBEiYKGWFudGlfcm9sbGJhY2tfdXNhZ2VfdGFibGUYBiABKAhIBYgBARIYCgtzcm1fdmVyc2lvbhgHIAEoDUgGiAEBEhsKDmNhbl91cGRhdGVfc3JtGAggASgISAeIAQESdAoec3VwcG9ydGVkX2NlcnRpZmljYXRlX2tleV90eXBlGAkgAygOMkwubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXMuQ2VydGlmaWNhdGVLZXlUeXBlEnsKGmFuYWxvZ19vdXRwdXRfY2FwYWJpbGl0aWVzGAogASgOMlIubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXMuQW5hbG9nT3V0cHV0Q2FwYWJpbGl0aWVzSAiIAQESJgoZY2FuX2Rpc2FibGVfYW5hbG9nX291dHB1dBgLIAEoCEgJiAEBEiEKFHJlc291cmNlX3JhdGluZ190aWVyGAwgASgNSAqIAQEigAEKC0hkY3BWZXJzaW9uEg0KCUhEQ1BfTk9ORRAAEgsKB0hEQ1BfVjEQARILCgdIRENQX1YyEAISDQoJSERDUF9WMl8xEAMSDQoJSERDUF9WMl8yEAQSDQoJSERDUF9WMl8zEAUSGwoWSERDUF9OT19ESUdJVEFMX09VVFBVVBD/ASJpChJDZXJ0aWZpY2F0ZUtleVR5cGUSDAoIUlNBXzIwNDgQABIMCghSU0FfMzA3MhABEhEKDUVDQ19TRUNQMjU2UjEQAhIRCg1FQ0NfU0VDUDM4NFIxEAMSEQoNRUNDX1NFQ1A1MjFSMRAEIo0BChhBbmFsb2dPdXRwdXRDYXBhYmlsaXRpZXMSGQoVQU5BTE9HX09VVFBVVF9VTktOT1dOEAASFgoSQU5BTE9HX09VVFBVVF9OT05FEAESGwoXQU5BTE9HX09VVFBVVF9TVVBQT1JURUQQAhIhCh1BTkFMT0dfT1VUUFVUX1NVUFBPUlRTX0NHTVNfQRADQg8KDV9jbGllbnRfdG9rZW5CEAoOX3Nlc3Npb25fdG9rZW5CHwodX3ZpZGVvX3Jlc29sdXRpb25fY29uc3RyYWludHNCEwoRX21heF9oZGNwX3ZlcnNpb25CGQoXX29lbV9jcnlwdG9fYXBpX3ZlcnNpb25CHAoaX2FudGlfcm9sbGJhY2tfdXNhZ2VfdGFibGVCDgoMX3NybV92ZXJzaW9uQhEKD19jYW5fdXBkYXRlX3NybUIdChtfYW5hbG9nX291dHB1dF9jYXBhYmlsaXRpZXNCHAoaX2Nhbl9kaXNhYmxlX2FuYWxvZ19vdXRwdXRCFwoVX3Jlc291cmNlX3JhdGluZ190aWVyGn8KEUNsaWVudENyZWRlbnRpYWxzEkMKBHR5cGUYASABKA4yMC5saWNlbnNlX3Byb3RvY29sLkNsaWVudElkZW50aWZpY2F0aW9uLlRva2VuVHlwZUgAiAEBEhIKBXRva2VuGAIgASgMSAGIAQFCBwoFX3R5cGVCCAoGX3Rva2VuInMKCVRva2VuVHlwZRIKCgZLRVlCT1gQABIaChZEUk1fREVWSUNFX0NFUlRJRklDQVRFEAESIgoeUkVNT1RFX0FUVEVTVEFUSU9OX0NFUlRJRklDQVRFEAISGgoWT0VNX0RFVklDRV9DRVJUSUZJQ0FURRADQgcKBV90eXBlQggKBl90b2tlbkIYChZfcHJvdmlkZXJfY2xpZW50X3Rva2VuQhIKEF9saWNlbnNlX2NvdW50ZXJCFgoUX2NsaWVudF9jYXBhYmlsaXRpZXNCCwoJX3ZtcF9kYXRhItcCCh1FbmNyeXB0ZWRDbGllbnRJZGVudGlmaWNhdGlvbhIYCgtwcm92aWRlcl9pZBgBIAEoCUgAiAEBEi4KIXNlcnZpY2VfY2VydGlmaWNhdGVfc2VyaWFsX251bWJlchgCIAEoDEgBiAEBEiAKE2VuY3J5cHRlZF9jbGllbnRfaWQYAyABKAxIAogBARIjChZlbmNyeXB0ZWRfY2xpZW50X2lkX2l2GAQgASgMSAOIAQESIgoVZW5jcnlwdGVkX3ByaXZhY3lfa2V5GAUgASgMSASIAQFCDgoMX3Byb3ZpZGVyX2lkQiQKIl9zZXJ2aWNlX2NlcnRpZmljYXRlX3NlcmlhbF9udW1iZXJCFgoUX2VuY3J5cHRlZF9jbGllbnRfaWRCGQoXX2VuY3J5cHRlZF9jbGllbnRfaWRfaXZCGAoWX2VuY3J5cHRlZF9wcml2YWN5X2tleSKdCQoORHJtQ2VydGlmaWNhdGUSOAoEdHlwZRgBIAEoDjIlLmxpY2Vuc2VfcHJvdG9jb2wuRHJtQ2VydGlmaWNhdGUuVHlwZUgAiAEBEhoKDXNlcmlhbF9udW1iZXIYAiABKAxIAYgBARIiChVjcmVhdGlvbl90aW1lX3NlY29uZHMYAyABKA1IAogBARIkChdleHBpcmF0aW9uX3RpbWVfc2Vjb25kcxgMIAEoDUgDiAEBEhcKCnB1YmxpY19rZXkYBCABKAxIBIgBARIWCglzeXN0ZW1faWQYBSABKA1IBYgBARInChZ0ZXN0X2RldmljZV9kZXByZWNhdGVkGAYgASgIQgIYAUgGiAEBEhgKC3Byb3ZpZGVyX2lkGAcgASgJSAeIAQESQwoNc2VydmljZV90eXBlcxgIIAMoDjIsLmxpY2Vuc2VfcHJvdG9jb2wuRHJtQ2VydGlmaWNhdGUuU2VydmljZVR5cGUSQgoJYWxnb3JpdGhtGAkgASgOMioubGljZW5zZV9wcm90b2NvbC5Ecm1DZXJ0aWZpY2F0ZS5BbGdvcml0aG1ICIgBARITCgZyb3RfaWQYCiABKAxICYgBARJLCg5lbmNyeXB0aW9uX2tleRgLIAEoCzIuLmxpY2Vuc2VfcHJvdG9jb2wuRHJtQ2VydGlmaWNhdGUuRW5jcnlwdGlvbktleUgKiAEBGokBCg1FbmNyeXB0aW9uS2V5EhcKCnB1YmxpY19rZXkYASABKAxIAIgBARJCCglhbGdvcml0aG0YAiABKA4yKi5saWNlbnNlX3Byb3RvY29sLkRybUNlcnRpZmljYXRlLkFsZ29yaXRobUgBiAEBQg0KC19wdWJsaWNfa2V5QgwKCl9hbGdvcml0aG0iTAoEVHlwZRIICgRST09UEAASEAoMREVWSUNFX01PREVMEAESCgoGREVWSUNFEAISCwoHU0VSVklDRRADEg8KC1BST1ZJU0lPTkVSEAQihgEKC1NlcnZpY2VUeXBlEhgKFFVOS05PV05fU0VSVklDRV9UWVBFEAASFgoSTElDRU5TRV9TRVJWRVJfU0RLEAESHAoYTElDRU5TRV9TRVJWRVJfUFJPWFlfU0RLEAISFAoQUFJPVklTSU9OSU5HX1NESxADEhEKDUNBU19QUk9YWV9TREsQBCJkCglBbGdvcml0aG0SFQoRVU5LTk9XTl9BTEdPUklUSE0QABIHCgNSU0EQARIRCg1FQ0NfU0VDUDI1NlIxEAISEQoNRUNDX1NFQ1AzODRSMRADEhEKDUVDQ19TRUNQNTIxUjEQBEIHCgVfdHlwZUIQCg5fc2VyaWFsX251bWJlckIYChZfY3JlYXRpb25fdGltZV9zZWNvbmRzQhoKGF9leHBpcmF0aW9uX3RpbWVfc2Vjb25kc0INCgtfcHVibGljX2tleUIMCgpfc3lzdGVtX2lkQhkKF190ZXN0X2RldmljZV9kZXByZWNhdGVkQg4KDF9wcm92aWRlcl9pZEIMCgpfYWxnb3JpdGhtQgkKB19yb3RfaWRCEQoPX2VuY3J5cHRpb25fa2V5IowCChRTaWduZWREcm1DZXJ0aWZpY2F0ZRIcCg9kcm1fY2VydGlmaWNhdGUYASABKAxIAIgBARIWCglzaWduYXR1cmUYAiABKAxIAYgBARI7CgZzaWduZXIYAyABKAsyJi5saWNlbnNlX3Byb3RvY29sLlNpZ25lZERybUNlcnRpZmljYXRlSAKIAQESQQoOaGFzaF9hbGdvcml0aG0YBCABKA4yJC5saWNlbnNlX3Byb3RvY29sLkhhc2hBbGdvcml0aG1Qcm90b0gDiAEBQhIKEF9kcm1fY2VydGlmaWNhdGVCDAoKX3NpZ25hdHVyZUIJCgdfc2lnbmVyQhEKD19oYXNoX2FsZ29yaXRobSK7CAoQV2lkZXZpbmVQc3NoRGF0YRIPCgdrZXlfaWRzGAIgAygMEhcKCmNvbnRlbnRfaWQYBCABKAxIAIgBARIgChNjcnlwdG9fcGVyaW9kX2luZGV4GAcgASgNSAGIAQESHgoRcHJvdGVjdGlvbl9zY2hlbWUYCSABKA1IAogBARIiChVjcnlwdG9fcGVyaW9kX3NlY29uZHMYCiABKA1IA4gBARI6CgR0eXBlGAsgASgOMicubGljZW5zZV9wcm90b2NvbC5XaWRldmluZVBzc2hEYXRhLlR5cGVIBIgBARIZCgxrZXlfc2VxdWVuY2UYDCABKA1IBYgBARIRCglncm91cF9pZHMYDSADKAwSRQoNZW50aXRsZWRfa2V5cxgOIAMoCzIuLmxpY2Vuc2VfcHJvdG9jb2wuV2lkZXZpbmVQc3NoRGF0YS5FbnRpdGxlZEtleRIaCg12aWRlb19mZWF0dXJlGA8gASgJSAaIAQESSAoJYWxnb3JpdGhtGAEgASgOMiwubGljZW5zZV9wcm90b2NvbC5XaWRldmluZVBzc2hEYXRhLkFsZ29yaXRobUICGAFIB4gBARIZCghwcm92aWRlchgDIAEoCUICGAFICIgBARIbCgp0cmFja190eXBlGAUgASgJQgIYAUgJiAEBEhcKBnBvbGljeRgGIAEoCUICGAFICogBARIgCg9ncm91cGVkX2xpY2Vuc2UYCCABKAxCAhgBSAuIAQEa3wEKC0VudGl0bGVkS2V5Eh8KEmVudGl0bGVtZW50X2tleV9pZBgBIAEoDEgAiAEBEhMKBmtleV9pZBgCIAEoDEgBiAEBEhAKA2tleRgDIAEoDEgCiAEBEg8KAml2GAQgASgMSAOIAQESJwoaZW50aXRsZW1lbnRfa2V5X3NpemVfYnl0ZXMYBSABKA1IBIgBAUIVChNfZW50aXRsZW1lbnRfa2V5X2lkQgkKB19rZXlfaWRCBgoEX2tleUIFCgNfaXZCHQobX2VudGl0bGVtZW50X2tleV9zaXplX2J5dGVzIjUKBFR5cGUSCgoGU0lOR0xFEAASDwoLRU5USVRMRU1FTlQQARIQCgxFTlRJVExFRF9LRVkQAiIoCglBbGdvcml0aG0SDwoLVU5FTkNSWVBURUQQABIKCgZBRVNDVFIQAUINCgtfY29udGVudF9pZEIWChRfY3J5cHRvX3BlcmlvZF9pbmRleEIUChJfcHJvdGVjdGlvbl9zY2hlbWVCGAoWX2NyeXB0b19wZXJpb2Rfc2Vjb25kc0IHCgVfdHlwZUIPCg1fa2V5X3NlcXVlbmNlQhAKDl92aWRlb19mZWF0dXJlQgwKCl9hbGdvcml0aG1CCwoJX3Byb3ZpZGVyQg0KC190cmFja190eXBlQgkKB19wb2xpY3lCEgoQX2dyb3VwZWRfbGljZW5zZSK4AgoKRmlsZUhhc2hlcxITCgZzaWduZXIYASABKAxIAIgBARI6CgpzaWduYXR1cmVzGAIgAygLMiYubGljZW5zZV9wcm90b2NvbC5GaWxlSGFzaGVzLlNpZ25hdHVyZRrNAQoJU2lnbmF0dXJlEhUKCGZpbGVuYW1lGAEgASgJSACIAQESGQoMdGVzdF9zaWduaW5nGAIgASgISAGIAQESFwoKU0hBNTEySGFzaBgDIAEoDEgCiAEBEhUKCG1haW5fZXhlGAQgASgISAOIAQESFgoJc2lnbmF0dXJlGAUgASgMSASIAQFCCwoJX2ZpbGVuYW1lQg8KDV90ZXN0X3NpZ25pbmdCDQoLX1NIQTUxMkhhc2hCCwoJX21haW5fZXhlQgwKCl9zaWduYXR1cmVCCQoHX3NpZ25lcipUCgtMaWNlbnNlVHlwZRIaChZMSUNFTlNFVFlQRV9VTlZFUklGSUVEEAASDQoJU1RSRUFNSU5HEAESCwoHT0ZGTElORRACEg0KCUFVVE9NQVRJQxADKtkBChpQbGF0Zm9ybVZlcmlmaWNhdGlvblN0YXR1cxIXChNQTEFURk9STV9VTlZFUklGSUVEEAASFQoRUExBVEZPUk1fVEFNUEVSRUQQARIeChpQTEFURk9STV9TT0ZUV0FSRV9WRVJJRklFRBACEh4KGlBMQVRGT1JNX0hBUkRXQVJFX1ZFUklGSUVEEAMSHAoYUExBVEZPUk1fTk9fVkVSSUZJQ0FUSU9OEAQSLQopUExBVEZPUk1fU0VDVVJFX1NUT1JBR0VfU09GVFdBUkVfVkVSSUZJRUQQBSpcCg9Qcm90b2NvbFZlcnNpb24SFgoSVkVSU0lPTl9VTlZFUklGSUVEEAASDwoLVkVSU0lPTl8yXzAQFBIPCgtWRVJTSU9OXzJfMRAVEg8KC1ZFUlNJT05fMl8yEBYqhgEKEkhhc2hBbGdvcml0aG1Qcm90bxIeChpIQVNIX0FMR09SSVRITV9VTlNQRUNJRklFRBAAEhgKFEhBU0hfQUxHT1JJVEhNX1NIQV8xEAESGgoWSEFTSF9BTEdPUklUSE1fU0hBXzI1NhACEhoKFkhBU0hfQUxHT1JJVEhNX1NIQV8zODQQA2IGcHJvdG8z'
	);

/**
 * LicenseIdentification is propagated from LicenseRequest to License,
 * incrementing version with each iteration.
 *
 * @generated from message license_protocol.LicenseIdentification
 */
export type LicenseIdentification = Message<'license_protocol.LicenseIdentification'> & {
	/**
	 * @generated from field: optional bytes request_id = 1;
	 */
	requestId?: Uint8Array;

	/**
	 * @generated from field: optional bytes session_id = 2;
	 */
	sessionId?: Uint8Array;

	/**
	 * @generated from field: optional bytes purchase_id = 3;
	 */
	purchaseId?: Uint8Array;

	/**
	 * @generated from field: optional license_protocol.LicenseType type = 4;
	 */
	type?: LicenseType;

	/**
	 * @generated from field: optional int32 version = 5;
	 */
	version?: number;

	/**
	 * @generated from field: optional bytes provider_session_token = 6;
	 */
	providerSessionToken?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseIdentification.
 * Use `create(LicenseIdentificationSchema)` to create a new message.
 */
export const LicenseIdentificationSchema: GenMessage<LicenseIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 0);

/**
 * @generated from message license_protocol.License
 */
export type License = Message<'license_protocol.License'> & {
	/**
	 * @generated from field: optional license_protocol.LicenseIdentification id = 1;
	 */
	id?: LicenseIdentification;

	/**
	 * @generated from field: optional license_protocol.License.Policy policy = 2;
	 */
	policy?: License_Policy;

	/**
	 * @generated from field: repeated license_protocol.License.KeyContainer key = 3;
	 */
	key: License_KeyContainer[];

	/**
	 * Time of the request in seconds (UTC) as set in
	 * LicenseRequest.request_time.  If this time is not set in the request,
	 * the local time at the license service is used in this field.
	 *
	 * @generated from field: optional int64 license_start_time = 4;
	 */
	licenseStartTime?: bigint;

	/**
	 * @generated from field: optional bool remote_attestation_verified = 5;
	 */
	remoteAttestationVerified?: boolean;

	/**
	 * Client token generated by the content provider. Optional.
	 *
	 * @generated from field: optional bytes provider_client_token = 6;
	 */
	providerClientToken?: Uint8Array;

	/**
	 * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
	 * specification. Propagated from Widevine PSSH box. Optional.
	 *
	 * @generated from field: optional uint32 protection_scheme = 7;
	 */
	protectionScheme?: number;

	/**
	 * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
	 * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
	 * depends on client max_hdcp_version).
	 * Additional details can be found in Widevine Modular DRM Security
	 * Integration Guide for CENC.
	 *
	 * @generated from field: optional bytes srm_requirement = 8;
	 */
	srmRequirement?: Uint8Array;

	/**
	 * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
	 * depending on client max_hdcp_version) that should be installed on the
	 * client device.
	 *
	 * @generated from field: optional bytes srm_update = 9;
	 */
	srmUpdate?: Uint8Array;

	/**
	 * Indicates the status of any type of platform verification performed by the
	 * server.
	 *
	 * @generated from field: optional license_protocol.PlatformVerificationStatus platform_verification_status = 10;
	 */
	platformVerificationStatus?: PlatformVerificationStatus;

	/**
	 * IDs of the groups for which keys are delivered in this license, if any.
	 *
	 * @generated from field: repeated bytes group_ids = 11;
	 */
	groupIds: Uint8Array[];
};

/**
 * Describes the message license_protocol.License.
 * Use `create(LicenseSchema)` to create a new message.
 */
export const LicenseSchema: GenMessage<License> = /*@__PURE__*/ messageDesc(file_license_protocol, 1);

/**
 * @generated from message license_protocol.License.Policy
 */
export type License_Policy = Message<'license_protocol.License.Policy'> & {
	/**
	 * Indicates that playback of the content is allowed.
	 *
	 * @generated from field: optional bool can_play = 1;
	 */
	canPlay?: boolean;

	/**
	 * Indicates that the license may be persisted to non-volatile
	 * storage for offline use.
	 *
	 * @generated from field: optional bool can_persist = 2;
	 */
	canPersist?: boolean;

	/**
	 * Indicates that renewal of this license is allowed.
	 *
	 * @generated from field: optional bool can_renew = 3;
	 */
	canRenew?: boolean;

	/**
	 * Indicates the rental window.
	 *
	 * @generated from field: optional int64 rental_duration_seconds = 4;
	 */
	rentalDurationSeconds?: bigint;

	/**
	 * Indicates the viewing window, once playback has begun.
	 *
	 * @generated from field: optional int64 playback_duration_seconds = 5;
	 */
	playbackDurationSeconds?: bigint;

	/**
	 * Indicates the time window for this specific license.
	 *
	 * @generated from field: optional int64 license_duration_seconds = 6;
	 */
	licenseDurationSeconds?: bigint;

	/**
	 * The window of time, in which playback is allowed to continue while
	 * renewal is attempted, yet unsuccessful due to backend problems with
	 * the license server.
	 *
	 * @generated from field: optional int64 renewal_recovery_duration_seconds = 7;
	 */
	renewalRecoveryDurationSeconds?: bigint;

	/**
	 * All renewal requests for this license shall be directed to the
	 * specified URL.
	 *
	 * @generated from field: optional string renewal_server_url = 8;
	 */
	renewalServerUrl?: string;

	/**
	 * How many seconds after license_start_time, before renewal is first
	 * attempted.
	 *
	 * @generated from field: optional int64 renewal_delay_seconds = 9;
	 */
	renewalDelaySeconds?: bigint;

	/**
	 * Specifies the delay in seconds between subsequent license
	 * renewal requests, in case of failure.
	 *
	 * @generated from field: optional int64 renewal_retry_interval_seconds = 10;
	 */
	renewalRetryIntervalSeconds?: bigint;

	/**
	 * Indicates that the license shall be sent for renewal when usage is
	 * started.
	 *
	 * @generated from field: optional bool renew_with_usage = 11;
	 */
	renewWithUsage?: boolean;

	/**
	 * Indicates to client that license renewal and release requests ought to
	 * include ClientIdentification (client_id).
	 *
	 * @generated from field: optional bool always_include_client_id = 12;
	 */
	alwaysIncludeClientId?: boolean;

	/**
	 * Duration of grace period before playback_duration_seconds (short window)
	 * goes into effect. Optional.
	 *
	 * @generated from field: optional int64 play_start_grace_period_seconds = 13;
	 */
	playStartGracePeriodSeconds?: bigint;

	/**
	 * Enables "soft enforcement" of playback_duration_seconds, letting the user
	 * finish playback even if short window expires. Optional.
	 *
	 * @generated from field: optional bool soft_enforce_playback_duration = 14;
	 */
	softEnforcePlaybackDuration?: boolean;

	/**
	 * Enables "soft enforcement" of rental_duration_seconds. Initial playback
	 * must always start before rental duration expires.  In order to allow
	 * subsequent playbacks to start after the rental duration expires,
	 * soft_enforce_playback_duration must be true. Otherwise, subsequent
	 * playbacks will not be allowed once rental duration expires. Optional.
	 *
	 * @generated from field: optional bool soft_enforce_rental_duration = 15;
	 */
	softEnforceRentalDuration?: boolean;
};

/**
 * Describes the message license_protocol.License.Policy.
 * Use `create(License_PolicySchema)` to create a new message.
 */
export const License_PolicySchema: GenMessage<License_Policy> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 0);

/**
 * @generated from message license_protocol.License.KeyContainer
 */
export type License_KeyContainer = Message<'license_protocol.License.KeyContainer'> & {
	/**
	 * @generated from field: optional bytes id = 1;
	 */
	id?: Uint8Array;

	/**
	 * @generated from field: optional bytes iv = 2;
	 */
	iv?: Uint8Array;

	/**
	 * @generated from field: optional bytes key = 3;
	 */
	key?: Uint8Array;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.KeyType type = 4;
	 */
	type?: License_KeyContainer_KeyType;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.SecurityLevel level = 5;
	 */
	level?: License_KeyContainer_SecurityLevel;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection required_protection = 6;
	 */
	requiredProtection?: License_KeyContainer_OutputProtection;

	/**
	 * NOTE: Use of requested_protection is not recommended as it is only
	 * supported on a small number of platforms.
	 *
	 * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection requested_protection = 7;
	 */
	requestedProtection?: License_KeyContainer_OutputProtection;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.KeyControl key_control = 8;
	 */
	keyControl?: License_KeyContainer_KeyControl;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
	 */
	operatorSessionKeyPermissions?: License_KeyContainer_OperatorSessionKeyPermissions;

	/**
	 * Optional video resolution constraints. If the video resolution of the
	 * content being decrypted/decoded falls within one of the specified ranges,
	 * the optional required_protections may be applied. Otherwise an error will
	 * be reported.
	 * NOTE: Use of this feature is not recommended, as it is only supported on
	 * a small number of platforms.
	 *
	 * @generated from field: repeated license_protocol.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
	 */
	videoResolutionConstraints: License_KeyContainer_VideoResolutionConstraint[];

	/**
	 * Optional flag to indicate the key must only be used if the client
	 * supports anti rollback of the user table.  Content provider can query the
	 * client capabilities to determine if the client support this feature.
	 *
	 * @generated from field: optional bool anti_rollback_usage_table = 11;
	 */
	antiRollbackUsageTable?: boolean;

	/**
	 * Optional not limited to commonly known track types such as SD, HD.
	 * It can be some provider defined label to identify the track.
	 *
	 * @generated from field: optional string track_label = 12;
	 */
	trackLabel?: string;
};

/**
 * Describes the message license_protocol.License.KeyContainer.
 * Use `create(License_KeyContainerSchema)` to create a new message.
 */
export const License_KeyContainerSchema: GenMessage<License_KeyContainer> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 1);

/**
 * @generated from message license_protocol.License.KeyContainer.KeyControl
 */
export type License_KeyContainer_KeyControl = Message<'license_protocol.License.KeyContainer.KeyControl'> & {
	/**
	 * |key_control| is documented in:
	 * Widevine Modular DRM Security Integration Guide for CENC
	 * If present, the key control must be communicated to the secure
	 * environment prior to any usage. This message is automatically generated
	 * by the Widevine License Server SDK.
	 *
	 * @generated from field: optional bytes key_control_block = 1;
	 */
	keyControlBlock?: Uint8Array;

	/**
	 * @generated from field: optional bytes iv = 2;
	 */
	iv?: Uint8Array;
};

/**
 * Describes the message license_protocol.License.KeyContainer.KeyControl.
 * Use `create(License_KeyContainer_KeyControlSchema)` to create a new message.
 */
export const License_KeyContainer_KeyControlSchema: GenMessage<License_KeyContainer_KeyControl> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 1, 0);

/**
 * @generated from message license_protocol.License.KeyContainer.OutputProtection
 */
export type License_KeyContainer_OutputProtection = Message<'license_protocol.License.KeyContainer.OutputProtection'> & {
	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.HDCP hdcp = 1;
	 */
	hdcp?: License_KeyContainer_OutputProtection_HDCP;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2;
	 */
	cgmsFlags?: License_KeyContainer_OutputProtection_CGMS;

	/**
	 * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3;
	 */
	hdcpSrmRule?: License_KeyContainer_OutputProtection_HdcpSrmRule;

	/**
	 * Optional requirement to indicate analog output is not allowed.
	 *
	 * @generated from field: optional bool disable_analog_output = 4;
	 */
	disableAnalogOutput?: boolean;

	/**
	 * Optional requirement to indicate digital output is not allowed.
	 *
	 * @generated from field: optional bool disable_digital_output = 5;
	 */
	disableDigitalOutput?: boolean;
};

/**
 * Describes the message license_protocol.License.KeyContainer.OutputProtection.
 * Use `create(License_KeyContainer_OutputProtectionSchema)` to create a new message.
 */
export const License_KeyContainer_OutputProtectionSchema: GenMessage<License_KeyContainer_OutputProtection> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 1, 1);

/**
 * Indicates whether HDCP is required on digital outputs, and which
 * version should be used.
 *
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.HDCP
 */
export enum License_KeyContainer_OutputProtection_HDCP {
	/**
	 * @generated from enum value: HDCP_NONE = 0;
	 */
	HDCP_NONE = 0,

	/**
	 * @generated from enum value: HDCP_V1 = 1;
	 */
	HDCP_V1 = 1,

	/**
	 * @generated from enum value: HDCP_V2 = 2;
	 */
	HDCP_V2 = 2,

	/**
	 * @generated from enum value: HDCP_V2_1 = 3;
	 */
	HDCP_V2_1 = 3,

	/**
	 * @generated from enum value: HDCP_V2_2 = 4;
	 */
	HDCP_V2_2 = 4,

	/**
	 * @generated from enum value: HDCP_V2_3 = 5;
	 */
	HDCP_V2_3 = 5,

	/**
	 * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
	 */
	HDCP_NO_DIGITAL_OUTPUT = 255
}

/**
 * Describes the enum license_protocol.License.KeyContainer.OutputProtection.HDCP.
 */
export const License_KeyContainer_OutputProtection_HDCPSchema: GenEnum<License_KeyContainer_OutputProtection_HDCP> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 1, 0);

/**
 * Indicate the CGMS setting to be inserted on analog output.
 *
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.CGMS
 */
export enum License_KeyContainer_OutputProtection_CGMS {
	/**
	 * @generated from enum value: COPY_FREE = 0;
	 */
	COPY_FREE = 0,

	/**
	 * @generated from enum value: CGMS_NONE = 42;
	 */
	CGMS_NONE = 42,

	/**
	 * @generated from enum value: COPY_ONCE = 2;
	 */
	COPY_ONCE = 2,

	/**
	 * @generated from enum value: COPY_NEVER = 3;
	 */
	COPY_NEVER = 3
}

/**
 * Describes the enum license_protocol.License.KeyContainer.OutputProtection.CGMS.
 */
export const License_KeyContainer_OutputProtection_CGMSSchema: GenEnum<License_KeyContainer_OutputProtection_CGMS> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 1, 1);

/**
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule
 */
export enum License_KeyContainer_OutputProtection_HdcpSrmRule {
	/**
	 * @generated from enum value: HDCP_SRM_RULE_NONE = 0;
	 */
	HDCP_SRM_RULE_NONE = 0,

	/**
	 * In 'required_protection', this means most current SRM is required.
	 * Update the SRM on the device. If update cannot happen,
	 * do not allow the key.
	 * In 'requested_protection', this means most current SRM is requested.
	 * Update the SRM on the device. If update cannot happen,
	 * allow use of the key anyway.
	 *
	 * @generated from enum value: CURRENT_SRM = 1;
	 */
	CURRENT_SRM = 1
}

/**
 * Describes the enum license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule.
 */
export const License_KeyContainer_OutputProtection_HdcpSrmRuleSchema: GenEnum<License_KeyContainer_OutputProtection_HdcpSrmRule> =
	/*@__PURE__*/
	enumDesc(file_license_protocol, 1, 1, 1, 2);

/**
 * @generated from message license_protocol.License.KeyContainer.VideoResolutionConstraint
 */
export type License_KeyContainer_VideoResolutionConstraint = Message<'license_protocol.License.KeyContainer.VideoResolutionConstraint'> & {
	/**
	 * Minimum and maximum video resolutions in the range (height x width).
	 *
	 * @generated from field: optional uint32 min_resolution_pixels = 1;
	 */
	minResolutionPixels?: number;

	/**
	 * @generated from field: optional uint32 max_resolution_pixels = 2;
	 */
	maxResolutionPixels?: number;

	/**
	 * Optional output protection requirements for this range. If not
	 * specified, the OutputProtection in the KeyContainer applies.
	 *
	 * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection required_protection = 3;
	 */
	requiredProtection?: License_KeyContainer_OutputProtection;
};

/**
 * Describes the message license_protocol.License.KeyContainer.VideoResolutionConstraint.
 * Use `create(License_KeyContainer_VideoResolutionConstraintSchema)` to create a new message.
 */
export const License_KeyContainer_VideoResolutionConstraintSchema: GenMessage<License_KeyContainer_VideoResolutionConstraint> =
	/*@__PURE__*/
	messageDesc(file_license_protocol, 1, 1, 2);

/**
 * @generated from message license_protocol.License.KeyContainer.OperatorSessionKeyPermissions
 */
export type License_KeyContainer_OperatorSessionKeyPermissions = Message<'license_protocol.License.KeyContainer.OperatorSessionKeyPermissions'> & {
	/**
	 * Permissions/key usage flags for operator service keys
	 * (type = OPERATOR_SESSION).
	 *
	 * @generated from field: optional bool allow_encrypt = 1;
	 */
	allowEncrypt?: boolean;

	/**
	 * @generated from field: optional bool allow_decrypt = 2;
	 */
	allowDecrypt?: boolean;

	/**
	 * @generated from field: optional bool allow_sign = 3;
	 */
	allowSign?: boolean;

	/**
	 * @generated from field: optional bool allow_signature_verify = 4;
	 */
	allowSignatureVerify?: boolean;
};

/**
 * Describes the message license_protocol.License.KeyContainer.OperatorSessionKeyPermissions.
 * Use `create(License_KeyContainer_OperatorSessionKeyPermissionsSchema)` to create a new message.
 */
export const License_KeyContainer_OperatorSessionKeyPermissionsSchema: GenMessage<License_KeyContainer_OperatorSessionKeyPermissions> =
	/*@__PURE__*/
	messageDesc(file_license_protocol, 1, 1, 3);

/**
 * @generated from enum license_protocol.License.KeyContainer.KeyType
 */
export enum License_KeyContainer_KeyType {
	/**
	 * @generated from enum value: KEYTYPE_UNVERIFIED = 0;
	 */
	KEYTYPE_UNVERIFIED = 0,

	/**
	 * Exactly one key of this type must appear.
	 *
	 * @generated from enum value: SIGNING = 1;
	 */
	SIGNING = 1,

	/**
	 * Content key.
	 *
	 * @generated from enum value: CONTENT = 2;
	 */
	CONTENT = 2,

	/**
	 * Key control block for license renewals. No key.
	 *
	 * @generated from enum value: KEY_CONTROL = 3;
	 */
	KEY_CONTROL = 3,

	/**
	 * wrapped keys for auxiliary crypto operations.
	 *
	 * @generated from enum value: OPERATOR_SESSION = 4;
	 */
	OPERATOR_SESSION = 4,

	/**
	 * Entitlement keys.
	 *
	 * @generated from enum value: ENTITLEMENT = 5;
	 */
	ENTITLEMENT = 5,

	/**
	 * Partner-specific content key.
	 *
	 * @generated from enum value: OEM_CONTENT = 6;
	 */
	OEM_CONTENT = 6
}

/**
 * Describes the enum license_protocol.License.KeyContainer.KeyType.
 */
export const License_KeyContainer_KeyTypeSchema: GenEnum<License_KeyContainer_KeyType> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 0);

/**
 * The SecurityLevel enumeration allows the server to communicate the level
 * of robustness required by the client, in order to use the key.
 *
 * @generated from enum license_protocol.License.KeyContainer.SecurityLevel
 */
export enum License_KeyContainer_SecurityLevel {
	/**
	 * @generated from enum value: SECURITYLEVEL_UNVERIFIED = 0;
	 */
	SECURITYLEVEL_UNVERIFIED = 0,

	/**
	 * Software-based whitebox crypto is required.
	 *
	 * @generated from enum value: SW_SECURE_CRYPTO = 1;
	 */
	SW_SECURE_CRYPTO = 1,

	/**
	 * Software crypto and an obfuscated decoder is required.
	 *
	 * @generated from enum value: SW_SECURE_DECODE = 2;
	 */
	SW_SECURE_DECODE = 2,

	/**
	 * The key material and crypto operations must be performed within a
	 * hardware backed trusted execution environment.
	 *
	 * @generated from enum value: HW_SECURE_CRYPTO = 3;
	 */
	HW_SECURE_CRYPTO = 3,

	/**
	 * The crypto and decoding of content must be performed within a hardware
	 * backed trusted execution environment.
	 *
	 * @generated from enum value: HW_SECURE_DECODE = 4;
	 */
	HW_SECURE_DECODE = 4,

	/**
	 * The crypto, decoding and all handling of the media (compressed and
	 * uncompressed) must be handled within a hardware backed trusted
	 * execution environment.
	 *
	 * @generated from enum value: HW_SECURE_ALL = 5;
	 */
	HW_SECURE_ALL = 5
}

/**
 * Describes the enum license_protocol.License.KeyContainer.SecurityLevel.
 */
export const License_KeyContainer_SecurityLevelSchema: GenEnum<License_KeyContainer_SecurityLevel> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 1);

/**
 * @generated from message license_protocol.LicenseRequest
 */
export type LicenseRequest = Message<'license_protocol.LicenseRequest'> & {
	/**
	 * The client_id provides information authenticating the calling device.  It
	 * contains the Widevine keybox token that was installed on the device at the
	 * factory.  This field or encrypted_client_id below is required for a valid
	 * license request, but both should never be present in the same request.
	 *
	 * @generated from field: optional license_protocol.ClientIdentification client_id = 1;
	 */
	clientId?: ClientIdentification;

	/**
	 * @generated from field: optional license_protocol.LicenseRequest.ContentIdentification content_id = 2;
	 */
	contentId?: LicenseRequest_ContentIdentification;

	/**
	 * @generated from field: optional license_protocol.LicenseRequest.RequestType type = 3;
	 */
	type?: LicenseRequest_RequestType;

	/**
	 * Time of the request in seconds (UTC) as set by the client.
	 *
	 * @generated from field: optional int64 request_time = 4;
	 */
	requestTime?: bigint;

	/**
	 * Old-style decimal-encoded string key control nonce.
	 *
	 * @generated from field: optional bytes key_control_nonce_deprecated = 5;
	 */
	keyControlNonceDeprecated?: Uint8Array;

	/**
	 * @generated from field: optional license_protocol.ProtocolVersion protocol_version = 6;
	 */
	protocolVersion?: ProtocolVersion;

	/**
	 * New-style uint32 key control nonce, please use instead of
	 * key_control_nonce_deprecated.
	 *
	 * @generated from field: optional uint32 key_control_nonce = 7;
	 */
	keyControlNonce?: number;

	/**
	 * Encrypted ClientIdentification message, used for privacy purposes.
	 *
	 * @generated from field: optional license_protocol.EncryptedClientIdentification encrypted_client_id = 8;
	 */
	encryptedClientId?: EncryptedClientIdentification;
};

/**
 * Describes the message license_protocol.LicenseRequest.
 * Use `create(LicenseRequestSchema)` to create a new message.
 */
export const LicenseRequestSchema: GenMessage<LicenseRequest> = /*@__PURE__*/ messageDesc(file_license_protocol, 2);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification
 */
export type LicenseRequest_ContentIdentification = Message<'license_protocol.LicenseRequest.ContentIdentification'> & {
	/**
	 * @generated from oneof license_protocol.LicenseRequest.ContentIdentification.content_id_variant
	 */
	contentIdVariant:
		| {
				/**
				 * Exactly one of these must be present.
				 *
				 * @generated from field: license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;
				 */
				value: LicenseRequest_ContentIdentification_WidevinePsshData;
				case: 'widevinePsshData';
		  }
		| {
				/**
				 * @generated from field: license_protocol.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;
				 */
				value: LicenseRequest_ContentIdentification_WebmKeyId;
				case: 'webmKeyId';
		  }
		| {
				/**
				 * @generated from field: license_protocol.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;
				 */
				value: LicenseRequest_ContentIdentification_ExistingLicense;
				case: 'existingLicense';
		  }
		| {
				/**
				 * @generated from field: license_protocol.LicenseRequest.ContentIdentification.InitData init_data = 4;
				 */
				value: LicenseRequest_ContentIdentification_InitData;
				case: 'initData';
		  }
		| { case: undefined; value?: undefined };
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.
 * Use `create(LicenseRequest_ContentIdentificationSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentificationSchema: GenMessage<LicenseRequest_ContentIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 2, 0);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData
 */
export type LicenseRequest_ContentIdentification_WidevinePsshData = Message<'license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData'> & {
	/**
	 * @generated from field: repeated bytes pssh_data = 1;
	 */
	psshData: Uint8Array[];

	/**
	 * @generated from field: optional license_protocol.LicenseType license_type = 2;
	 */
	licenseType?: LicenseType;

	/**
	 * Opaque, client-specified.
	 *
	 * @generated from field: optional bytes request_id = 3;
	 */
	requestId?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData.
 * Use `create(LicenseRequest_ContentIdentification_WidevinePsshDataSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_WidevinePsshDataSchema: GenMessage<LicenseRequest_ContentIdentification_WidevinePsshData> =
	/*@__PURE__*/
	messageDesc(file_license_protocol, 2, 0, 0);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.WebmKeyId
 */
export type LicenseRequest_ContentIdentification_WebmKeyId = Message<'license_protocol.LicenseRequest.ContentIdentification.WebmKeyId'> & {
	/**
	 * @generated from field: optional bytes header = 1;
	 */
	header?: Uint8Array;

	/**
	 * @generated from field: optional license_protocol.LicenseType license_type = 2;
	 */
	licenseType?: LicenseType;

	/**
	 * Opaque, client-specified.
	 *
	 * @generated from field: optional bytes request_id = 3;
	 */
	requestId?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.WebmKeyId.
 * Use `create(LicenseRequest_ContentIdentification_WebmKeyIdSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_WebmKeyIdSchema: GenMessage<LicenseRequest_ContentIdentification_WebmKeyId> =
	/*@__PURE__*/
	messageDesc(file_license_protocol, 2, 0, 1);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.ExistingLicense
 */
export type LicenseRequest_ContentIdentification_ExistingLicense = Message<'license_protocol.LicenseRequest.ContentIdentification.ExistingLicense'> & {
	/**
	 * @generated from field: optional license_protocol.LicenseIdentification license_id = 1;
	 */
	licenseId?: LicenseIdentification;

	/**
	 * @generated from field: optional int64 seconds_since_started = 2;
	 */
	secondsSinceStarted?: bigint;

	/**
	 * @generated from field: optional int64 seconds_since_last_played = 3;
	 */
	secondsSinceLastPlayed?: bigint;

	/**
	 * @generated from field: optional bytes session_usage_table_entry = 4;
	 */
	sessionUsageTableEntry?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.ExistingLicense.
 * Use `create(LicenseRequest_ContentIdentification_ExistingLicenseSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_ExistingLicenseSchema: GenMessage<LicenseRequest_ContentIdentification_ExistingLicense> =
	/*@__PURE__*/
	messageDesc(file_license_protocol, 2, 0, 2);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.InitData
 */
export type LicenseRequest_ContentIdentification_InitData = Message<'license_protocol.LicenseRequest.ContentIdentification.InitData'> & {
	/**
	 * @generated from field: optional license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1;
	 */
	initDataType?: LicenseRequest_ContentIdentification_InitData_InitDataType;

	/**
	 * @generated from field: optional bytes init_data = 2;
	 */
	initData?: Uint8Array;

	/**
	 * @generated from field: optional license_protocol.LicenseType license_type = 3;
	 */
	licenseType?: LicenseType;

	/**
	 * @generated from field: optional bytes request_id = 4;
	 */
	requestId?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.InitData.
 * Use `create(LicenseRequest_ContentIdentification_InitDataSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_InitDataSchema: GenMessage<LicenseRequest_ContentIdentification_InitData> =
	/*@__PURE__*/
	messageDesc(file_license_protocol, 2, 0, 3);

/**
 * @generated from enum license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType
 */
export enum LicenseRequest_ContentIdentification_InitData_InitDataType {
	/**
	 * @generated from enum value: INITDATATYPE_UNVERIFIED = 0;
	 */
	INITDATATYPE_UNVERIFIED = 0,

	/**
	 * @generated from enum value: CENC = 1;
	 */
	CENC = 1,

	/**
	 * @generated from enum value: WEBM = 2;
	 */
	WEBM = 2
}

/**
 * Describes the enum license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType.
 */
export const LicenseRequest_ContentIdentification_InitData_InitDataTypeSchema: GenEnum<LicenseRequest_ContentIdentification_InitData_InitDataType> =
	/*@__PURE__*/
	enumDesc(file_license_protocol, 2, 0, 3, 0);

/**
 * @generated from enum license_protocol.LicenseRequest.RequestType
 */
export enum LicenseRequest_RequestType {
	/**
	 * @generated from enum value: REQUESTTYPE_UNVERIFIED = 0;
	 */
	REQUESTTYPE_UNVERIFIED = 0,

	/**
	 * @generated from enum value: NEW = 1;
	 */
	NEW = 1,

	/**
	 * @generated from enum value: RENEWAL = 2;
	 */
	RENEWAL = 2,

	/**
	 * @generated from enum value: RELEASE = 3;
	 */
	RELEASE = 3
}

/**
 * Describes the enum license_protocol.LicenseRequest.RequestType.
 */
export const LicenseRequest_RequestTypeSchema: GenEnum<LicenseRequest_RequestType> = /*@__PURE__*/ enumDesc(file_license_protocol, 2, 0);

/**
 * @generated from message license_protocol.MetricData
 */
export type MetricData = Message<'license_protocol.MetricData'> & {
	/**
	 * 'stage' that is currently processing the SignedMessage.  Required.
	 *
	 * @generated from field: optional string stage_name = 1;
	 */
	stageName?: string;

	/**
	 * metric and associated value.
	 *
	 * @generated from field: repeated license_protocol.MetricData.TypeValue metric_data = 2;
	 */
	metricData: MetricData_TypeValue[];
};

/**
 * Describes the message license_protocol.MetricData.
 * Use `create(MetricDataSchema)` to create a new message.
 */
export const MetricDataSchema: GenMessage<MetricData> = /*@__PURE__*/ messageDesc(file_license_protocol, 3);

/**
 * @generated from message license_protocol.MetricData.TypeValue
 */
export type MetricData_TypeValue = Message<'license_protocol.MetricData.TypeValue'> & {
	/**
	 * @generated from field: optional license_protocol.MetricData.MetricType type = 1;
	 */
	type?: MetricData_MetricType;

	/**
	 * The value associated with 'type'.  For example if type == LATENCY, the
	 * value would be the time in microseconds spent in this 'stage'.
	 *
	 * @generated from field: optional int64 value = 2;
	 */
	value?: bigint;
};

/**
 * Describes the message license_protocol.MetricData.TypeValue.
 * Use `create(MetricData_TypeValueSchema)` to create a new message.
 */
export const MetricData_TypeValueSchema: GenMessage<MetricData_TypeValue> = /*@__PURE__*/ messageDesc(file_license_protocol, 3, 0);

/**
 * @generated from enum license_protocol.MetricData.MetricType
 */
export enum MetricData_MetricType {
	/**
	 * @generated from enum value: METRICTYPE_UNVERIFIED = 0;
	 */
	METRICTYPE_UNVERIFIED = 0,

	/**
	 * The time spent in the 'stage', specified in microseconds.
	 *
	 * @generated from enum value: LATENCY = 1;
	 */
	LATENCY = 1,

	/**
	 * The UNIX epoch timestamp at which the 'stage' was first accessed in
	 * microseconds.
	 *
	 * @generated from enum value: TIMESTAMP = 2;
	 */
	TIMESTAMP = 2
}

/**
 * Describes the enum license_protocol.MetricData.MetricType.
 */
export const MetricData_MetricTypeSchema: GenEnum<MetricData_MetricType> = /*@__PURE__*/ enumDesc(file_license_protocol, 3, 0);

/**
 * @generated from message license_protocol.VersionInfo
 */
export type VersionInfo = Message<'license_protocol.VersionInfo'> & {
	/**
	 * License SDK version reported by the Widevine License SDK. This field
	 * is populated automatically by the SDK.
	 *
	 * @generated from field: optional string license_sdk_version = 1;
	 */
	licenseSdkVersion?: string;

	/**
	 * Version of the service hosting the license SDK. This field is optional.
	 * It may be provided by the hosting service.
	 *
	 * @generated from field: optional string license_service_version = 2;
	 */
	licenseServiceVersion?: string;
};

/**
 * Describes the message license_protocol.VersionInfo.
 * Use `create(VersionInfoSchema)` to create a new message.
 */
export const VersionInfoSchema: GenMessage<VersionInfo> = /*@__PURE__*/ messageDesc(file_license_protocol, 4);

/**
 * @generated from message license_protocol.SignedMessage
 */
export type SignedMessage = Message<'license_protocol.SignedMessage'> & {
	/**
	 * @generated from field: optional license_protocol.SignedMessage.MessageType type = 1;
	 */
	type?: SignedMessage_MessageType;

	/**
	 * @generated from field: optional bytes msg = 2;
	 */
	msg?: Uint8Array;

	/**
	 * Required field that contains the signature of the bytes of msg.
	 * For license requests, the signing algorithm is determined by the
	 * certificate contained in the request.
	 * For license responses, the signing algorithm is HMAC with signing key based
	 * on |session_key|.
	 *
	 * @generated from field: optional bytes signature = 3;
	 */
	signature?: Uint8Array;

	/**
	 * If populated, the contents of this field will be signaled by the
	 * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
	 * key is the bytes of an encrypted AES key. If the |session_key_type| is
	 * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
	 * serialized ECC public key.
	 *
	 * @generated from field: optional bytes session_key = 4;
	 */
	sessionKey?: Uint8Array;

	/**
	 * Remote attestation data which will be present in the initial license
	 * request for ChromeOS client devices operating in verified mode. Remote
	 * attestation challenge data is |msg| field above. Optional.
	 *
	 * @generated from field: optional bytes remote_attestation = 5;
	 */
	remoteAttestation?: Uint8Array;

	/**
	 * @generated from field: repeated license_protocol.MetricData metric_data = 6;
	 */
	metricData: MetricData[];

	/**
	 * Version information from the SDK and license service. This information is
	 * provided in the license response.
	 *
	 * @generated from field: optional license_protocol.VersionInfo service_version_info = 7;
	 */
	serviceVersionInfo?: VersionInfo;

	/**
	 * Optional field that contains the algorithm type used to generate the
	 * session_key and signature in a LICENSE message.
	 *
	 * @generated from field: optional license_protocol.SignedMessage.SessionKeyType session_key_type = 8;
	 */
	sessionKeyType?: SignedMessage_SessionKeyType;

	/**
	 * The core message is the simple serialization of fields used by OEMCrypto.
	 * This field was introduced in OEMCrypto API v16.
	 *
	 * @generated from field: optional bytes oemcrypto_core_message = 9;
	 */
	oemcryptoCoreMessage?: Uint8Array;
};

/**
 * Describes the message license_protocol.SignedMessage.
 * Use `create(SignedMessageSchema)` to create a new message.
 */
export const SignedMessageSchema: GenMessage<SignedMessage> = /*@__PURE__*/ messageDesc(file_license_protocol, 5);

/**
 * @generated from enum license_protocol.SignedMessage.MessageType
 */
export enum SignedMessage_MessageType {
	/**
	 * @generated from enum value: MESSAGETYPE_UNVERIFIED = 0;
	 */
	MESSAGETYPE_UNVERIFIED = 0,

	/**
	 * @generated from enum value: LICENSE_REQUEST = 1;
	 */
	LICENSE_REQUEST = 1,

	/**
	 * @generated from enum value: LICENSE = 2;
	 */
	LICENSE = 2,

	/**
	 * @generated from enum value: ERROR_RESPONSE = 3;
	 */
	ERROR_RESPONSE = 3,

	/**
	 * @generated from enum value: SERVICE_CERTIFICATE_REQUEST = 4;
	 */
	SERVICE_CERTIFICATE_REQUEST = 4,

	/**
	 * @generated from enum value: SERVICE_CERTIFICATE = 5;
	 */
	SERVICE_CERTIFICATE = 5,

	/**
	 * @generated from enum value: SUB_LICENSE = 6;
	 */
	SUB_LICENSE = 6,

	/**
	 * @generated from enum value: CAS_LICENSE_REQUEST = 7;
	 */
	CAS_LICENSE_REQUEST = 7,

	/**
	 * @generated from enum value: CAS_LICENSE = 8;
	 */
	CAS_LICENSE = 8,

	/**
	 * @generated from enum value: EXTERNAL_LICENSE_REQUEST = 9;
	 */
	EXTERNAL_LICENSE_REQUEST = 9,

	/**
	 * @generated from enum value: EXTERNAL_LICENSE = 10;
	 */
	EXTERNAL_LICENSE = 10
}

/**
 * Describes the enum license_protocol.SignedMessage.MessageType.
 */
export const SignedMessage_MessageTypeSchema: GenEnum<SignedMessage_MessageType> = /*@__PURE__*/ enumDesc(file_license_protocol, 5, 0);

/**
 * @generated from enum license_protocol.SignedMessage.SessionKeyType
 */
export enum SignedMessage_SessionKeyType {
	/**
	 * @generated from enum value: UNDEFINED = 0;
	 */
	UNDEFINED = 0,

	/**
	 * @generated from enum value: WRAPPED_AES_KEY = 1;
	 */
	WRAPPED_AES_KEY = 1,

	/**
	 * @generated from enum value: EPHERMERAL_ECC_PUBLIC_KEY = 2;
	 */
	EPHERMERAL_ECC_PUBLIC_KEY = 2
}

/**
 * Describes the enum license_protocol.SignedMessage.SessionKeyType.
 */
export const SignedMessage_SessionKeyTypeSchema: GenEnum<SignedMessage_SessionKeyType> = /*@__PURE__*/ enumDesc(file_license_protocol, 5, 1);

/**
 * ClientIdentification message used to authenticate the client device.
 *
 * @generated from message license_protocol.ClientIdentification
 */
export type ClientIdentification = Message<'license_protocol.ClientIdentification'> & {
	/**
	 * Type of factory-provisioned device root of trust. Optional.
	 *
	 * @generated from field: optional license_protocol.ClientIdentification.TokenType type = 1;
	 */
	type?: ClientIdentification_TokenType;

	/**
	 * Factory-provisioned device root of trust. Required.
	 *
	 * @generated from field: optional bytes token = 2;
	 */
	token?: Uint8Array;

	/**
	 * Optional client information name/value pairs.
	 *
	 * @generated from field: repeated license_protocol.ClientIdentification.NameValue client_info = 3;
	 */
	clientInfo: ClientIdentification_NameValue[];

	/**
	 * Client token generated by the content provider. Optional.
	 *
	 * @generated from field: optional bytes provider_client_token = 4;
	 */
	providerClientToken?: Uint8Array;

	/**
	 * Number of licenses received by the client to which the token above belongs.
	 * Only present if client_token is specified.
	 *
	 * @generated from field: optional uint32 license_counter = 5;
	 */
	licenseCounter?: number;

	/**
	 * List of non-baseline client capabilities.
	 *
	 * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities client_capabilities = 6;
	 */
	clientCapabilities?: ClientIdentification_ClientCapabilities;

	/**
	 * Serialized VmpData message. Optional.
	 *
	 * @generated from field: optional bytes vmp_data = 7;
	 */
	vmpData?: Uint8Array;

	/**
	 * Optional field that may contain additional provisioning credentials.
	 *
	 * @generated from field: repeated license_protocol.ClientIdentification.ClientCredentials device_credentials = 8;
	 */
	deviceCredentials: ClientIdentification_ClientCredentials[];
};

/**
 * Describes the message license_protocol.ClientIdentification.
 * Use `create(ClientIdentificationSchema)` to create a new message.
 */
export const ClientIdentificationSchema: GenMessage<ClientIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 6);

/**
 * @generated from message license_protocol.ClientIdentification.NameValue
 */
export type ClientIdentification_NameValue = Message<'license_protocol.ClientIdentification.NameValue'> & {
	/**
	 * @generated from field: optional string name = 1;
	 */
	name?: string;

	/**
	 * @generated from field: optional string value = 2;
	 */
	value?: string;
};

/**
 * Describes the message license_protocol.ClientIdentification.NameValue.
 * Use `create(ClientIdentification_NameValueSchema)` to create a new message.
 */
export const ClientIdentification_NameValueSchema: GenMessage<ClientIdentification_NameValue> = /*@__PURE__*/ messageDesc(file_license_protocol, 6, 0);

/**
 * Capabilities which not all clients may support. Used for the license
 * exchange protocol only.
 *
 * @generated from message license_protocol.ClientIdentification.ClientCapabilities
 */
export type ClientIdentification_ClientCapabilities = Message<'license_protocol.ClientIdentification.ClientCapabilities'> & {
	/**
	 * @generated from field: optional bool client_token = 1;
	 */
	clientToken?: boolean;

	/**
	 * @generated from field: optional bool session_token = 2;
	 */
	sessionToken?: boolean;

	/**
	 * @generated from field: optional bool video_resolution_constraints = 3;
	 */
	videoResolutionConstraints?: boolean;

	/**
	 * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4;
	 */
	maxHdcpVersion?: ClientIdentification_ClientCapabilities_HdcpVersion;

	/**
	 * @generated from field: optional uint32 oem_crypto_api_version = 5;
	 */
	oemCryptoApiVersion?: number;

	/**
	 * Client has hardware support for protecting the usage table, such as
	 * storing the generation number in secure memory.  For Details, see:
	 * Widevine Modular DRM Security Integration Guide for CENC
	 *
	 * @generated from field: optional bool anti_rollback_usage_table = 6;
	 */
	antiRollbackUsageTable?: boolean;

	/**
	 * The client shall report |srm_version| if available.
	 *
	 * @generated from field: optional uint32 srm_version = 7;
	 */
	srmVersion?: number;

	/**
	 * A device may have SRM data, and report a version, but may not be capable
	 * of updating SRM data.
	 *
	 * @generated from field: optional bool can_update_srm = 8;
	 */
	canUpdateSrm?: boolean;

	/**
	 * @generated from field: repeated license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;
	 */
	supportedCertificateKeyType: ClientIdentification_ClientCapabilities_CertificateKeyType[];

	/**
	 * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10;
	 */
	analogOutputCapabilities?: ClientIdentification_ClientCapabilities_AnalogOutputCapabilities;

	/**
	 * @generated from field: optional bool can_disable_analog_output = 11;
	 */
	canDisableAnalogOutput?: boolean;

	/**
	 * Clients can indicate a performance level supported by OEMCrypto.
	 * This will allow applications and providers to choose an appropriate
	 * quality of content to serve. Currently defined tiers are
	 * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
	 * the resource rating is unavailable or reporting erroneous values
	 * for that device. For details see,
	 * Widevine Modular DRM Security Integration Guide for CENC
	 *
	 * @generated from field: optional uint32 resource_rating_tier = 12;
	 */
	resourceRatingTier?: number;
};

/**
 * Describes the message license_protocol.ClientIdentification.ClientCapabilities.
 * Use `create(ClientIdentification_ClientCapabilitiesSchema)` to create a new message.
 */
export const ClientIdentification_ClientCapabilitiesSchema: GenMessage<ClientIdentification_ClientCapabilities> = /*@__PURE__*/ messageDesc(file_license_protocol, 6, 1);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion
 */
export enum ClientIdentification_ClientCapabilities_HdcpVersion {
	/**
	 * @generated from enum value: HDCP_NONE = 0;
	 */
	HDCP_NONE = 0,

	/**
	 * @generated from enum value: HDCP_V1 = 1;
	 */
	HDCP_V1 = 1,

	/**
	 * @generated from enum value: HDCP_V2 = 2;
	 */
	HDCP_V2 = 2,

	/**
	 * @generated from enum value: HDCP_V2_1 = 3;
	 */
	HDCP_V2_1 = 3,

	/**
	 * @generated from enum value: HDCP_V2_2 = 4;
	 */
	HDCP_V2_2 = 4,

	/**
	 * @generated from enum value: HDCP_V2_3 = 5;
	 */
	HDCP_V2_3 = 5,

	/**
	 * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
	 */
	HDCP_NO_DIGITAL_OUTPUT = 255
}

/**
 * Describes the enum license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion.
 */
export const ClientIdentification_ClientCapabilities_HdcpVersionSchema: GenEnum<ClientIdentification_ClientCapabilities_HdcpVersion> =
	/*@__PURE__*/
	enumDesc(file_license_protocol, 6, 1, 0);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType
 */
export enum ClientIdentification_ClientCapabilities_CertificateKeyType {
	/**
	 * @generated from enum value: RSA_2048 = 0;
	 */
	RSA_2048 = 0,

	/**
	 * @generated from enum value: RSA_3072 = 1;
	 */
	RSA_3072 = 1,

	/**
	 * @generated from enum value: ECC_SECP256R1 = 2;
	 */
	ECC_SECP256R1 = 2,

	/**
	 * @generated from enum value: ECC_SECP384R1 = 3;
	 */
	ECC_SECP384R1 = 3,

	/**
	 * @generated from enum value: ECC_SECP521R1 = 4;
	 */
	ECC_SECP521R1 = 4
}

/**
 * Describes the enum license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType.
 */
export const ClientIdentification_ClientCapabilities_CertificateKeyTypeSchema: GenEnum<ClientIdentification_ClientCapabilities_CertificateKeyType> =
	/*@__PURE__*/
	enumDesc(file_license_protocol, 6, 1, 1);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
 */
export enum ClientIdentification_ClientCapabilities_AnalogOutputCapabilities {
	/**
	 * @generated from enum value: ANALOG_OUTPUT_UNKNOWN = 0;
	 */
	ANALOG_OUTPUT_UNKNOWN = 0,

	/**
	 * @generated from enum value: ANALOG_OUTPUT_NONE = 1;
	 */
	ANALOG_OUTPUT_NONE = 1,

	/**
	 * @generated from enum value: ANALOG_OUTPUT_SUPPORTED = 2;
	 */
	ANALOG_OUTPUT_SUPPORTED = 2,

	/**
	 * @generated from enum value: ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3;
	 */
	ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3
}

/**
 * Describes the enum license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities.
 */
export const ClientIdentification_ClientCapabilities_AnalogOutputCapabilitiesSchema: GenEnum<ClientIdentification_ClientCapabilities_AnalogOutputCapabilities> =
	/*@__PURE__*/
	enumDesc(file_license_protocol, 6, 1, 2);

/**
 * @generated from message license_protocol.ClientIdentification.ClientCredentials
 */
export type ClientIdentification_ClientCredentials = Message<'license_protocol.ClientIdentification.ClientCredentials'> & {
	/**
	 * @generated from field: optional license_protocol.ClientIdentification.TokenType type = 1;
	 */
	type?: ClientIdentification_TokenType;

	/**
	 * @generated from field: optional bytes token = 2;
	 */
	token?: Uint8Array;
};

/**
 * Describes the message license_protocol.ClientIdentification.ClientCredentials.
 * Use `create(ClientIdentification_ClientCredentialsSchema)` to create a new message.
 */
export const ClientIdentification_ClientCredentialsSchema: GenMessage<ClientIdentification_ClientCredentials> = /*@__PURE__*/ messageDesc(file_license_protocol, 6, 2);

/**
 * @generated from enum license_protocol.ClientIdentification.TokenType
 */
export enum ClientIdentification_TokenType {
	/**
	 * @generated from enum value: KEYBOX = 0;
	 */
	KEYBOX = 0,

	/**
	 * @generated from enum value: DRM_DEVICE_CERTIFICATE = 1;
	 */
	DRM_DEVICE_CERTIFICATE = 1,

	/**
	 * @generated from enum value: REMOTE_ATTESTATION_CERTIFICATE = 2;
	 */
	REMOTE_ATTESTATION_CERTIFICATE = 2,

	/**
	 * @generated from enum value: OEM_DEVICE_CERTIFICATE = 3;
	 */
	OEM_DEVICE_CERTIFICATE = 3
}

/**
 * Describes the enum license_protocol.ClientIdentification.TokenType.
 */
export const ClientIdentification_TokenTypeSchema: GenEnum<ClientIdentification_TokenType> = /*@__PURE__*/ enumDesc(file_license_protocol, 6, 0);

/**
 * EncryptedClientIdentification message used to hold ClientIdentification
 * messages encrypted for privacy purposes.
 *
 * @generated from message license_protocol.EncryptedClientIdentification
 */
export type EncryptedClientIdentification = Message<'license_protocol.EncryptedClientIdentification'> & {
	/**
	 * Provider ID for which the ClientIdentifcation is encrypted (owner of
	 * service certificate).
	 *
	 * @generated from field: optional string provider_id = 1;
	 */
	providerId?: string;

	/**
	 * Serial number for the service certificate for which ClientIdentification is
	 * encrypted.
	 *
	 * @generated from field: optional bytes service_certificate_serial_number = 2;
	 */
	serviceCertificateSerialNumber?: Uint8Array;

	/**
	 * Serialized ClientIdentification message, encrypted with the privacy key
	 * using AES-128-CBC with PKCS#5 padding.
	 *
	 * @generated from field: optional bytes encrypted_client_id = 3;
	 */
	encryptedClientId?: Uint8Array;

	/**
	 * Initialization vector needed to decrypt encrypted_client_id.
	 *
	 * @generated from field: optional bytes encrypted_client_id_iv = 4;
	 */
	encryptedClientIdIv?: Uint8Array;

	/**
	 * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
	 *
	 * @generated from field: optional bytes encrypted_privacy_key = 5;
	 */
	encryptedPrivacyKey?: Uint8Array;
};

/**
 * Describes the message license_protocol.EncryptedClientIdentification.
 * Use `create(EncryptedClientIdentificationSchema)` to create a new message.
 */
export const EncryptedClientIdentificationSchema: GenMessage<EncryptedClientIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 7);

/**
 * DRM certificate definition for user devices, intermediate, service, and root
 * certificates.
 *
 * @generated from message license_protocol.DrmCertificate
 */
export type DrmCertificate = Message<'license_protocol.DrmCertificate'> & {
	/**
	 * Type of certificate. Required.
	 *
	 * @generated from field: optional license_protocol.DrmCertificate.Type type = 1;
	 */
	type?: DrmCertificate_Type;

	/**
	 * 128-bit globally unique serial number of certificate.
	 * Value is 0 for root certificate. Required.
	 *
	 * @generated from field: optional bytes serial_number = 2;
	 */
	serialNumber?: Uint8Array;

	/**
	 * POSIX time, in seconds, when the certificate was created. Required.
	 *
	 * @generated from field: optional uint32 creation_time_seconds = 3;
	 */
	creationTimeSeconds?: number;

	/**
	 * POSIX time, in seconds, when the certificate should expire. Value of zero
	 * denotes indefinite expiry time. For more information on limited lifespan
	 * DRM certificates see (go/limited-lifespan-drm-certificates).
	 *
	 * @generated from field: optional uint32 expiration_time_seconds = 12;
	 */
	expirationTimeSeconds?: number;

	/**
	 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
	 *
	 * @generated from field: optional bytes public_key = 4;
	 */
	publicKey?: Uint8Array;

	/**
	 * Widevine system ID for the device. Required for intermediate and
	 * user device certificates.
	 *
	 * @generated from field: optional uint32 system_id = 5;
	 */
	systemId?: number;

	/**
	 * Deprecated field, which used to indicate whether the device was a test
	 * (non-production) device. The test_device field in ProvisionedDeviceInfo
	 * below should be observed instead.
	 *
	 * @generated from field: optional bool test_device_deprecated = 6 [deprecated = true];
	 * @deprecated
	 */
	testDeviceDeprecated?: boolean;

	/**
	 * Service identifier (web origin) for the provider which owns the
	 * certificate. Required for service and provisioner certificates.
	 *
	 * @generated from field: optional string provider_id = 7;
	 */
	providerId?: string;

	/**
	 * This field is used only when type = SERVICE to specify which SDK uses
	 * service certificate. This repeated field is treated as a set. A certificate
	 * may be used for the specified service SDK if the appropriate ServiceType
	 * is specified in this field.
	 *
	 * @generated from field: repeated license_protocol.DrmCertificate.ServiceType service_types = 8;
	 */
	serviceTypes: DrmCertificate_ServiceType[];

	/**
	 * Required. The algorithm field contains the curve used to create the
	 * |public_key| if algorithm is one of the ECC types.
	 * The |algorithm| is used for both to determine the if the certificate is ECC
	 * or RSA. The |algorithm| also specifies the parameters that were used to
	 * create |public_key| and are used to create an ephemeral session key.
	 *
	 * @generated from field: optional license_protocol.DrmCertificate.Algorithm algorithm = 9;
	 */
	algorithm?: DrmCertificate_Algorithm;

	/**
	 * Optional. May be present in DEVICE certificate types. This is the root
	 * of trust identifier that holds an encrypted value that identifies the
	 * keybox or other root of trust that was used to provision a DEVICE drm
	 * certificate.
	 *
	 * @generated from field: optional bytes rot_id = 10;
	 */
	rotId?: Uint8Array;

	/**
	 * Optional. May be present in devices that explicitly support dual keys. When
	 * present the |public_key| is used for verification of received license
	 * request messages.
	 *
	 * @generated from field: optional license_protocol.DrmCertificate.EncryptionKey encryption_key = 11;
	 */
	encryptionKey?: DrmCertificate_EncryptionKey;
};

/**
 * Describes the message license_protocol.DrmCertificate.
 * Use `create(DrmCertificateSchema)` to create a new message.
 */
export const DrmCertificateSchema: GenMessage<DrmCertificate> = /*@__PURE__*/ messageDesc(file_license_protocol, 8);

/**
 * @generated from message license_protocol.DrmCertificate.EncryptionKey
 */
export type DrmCertificate_EncryptionKey = Message<'license_protocol.DrmCertificate.EncryptionKey'> & {
	/**
	 * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
	 *
	 * @generated from field: optional bytes public_key = 1;
	 */
	publicKey?: Uint8Array;

	/**
	 * Required. The algorithm field contains the curve used to create the
	 * |public_key| if algorithm is one of the ECC types.
	 * The |algorithm| is used for both to determine the if the certificate is
	 * ECC or RSA. The |algorithm| also specifies the parameters that were used
	 * to create |public_key| and are used to create an ephemeral session key.
	 *
	 * @generated from field: optional license_protocol.DrmCertificate.Algorithm algorithm = 2;
	 */
	algorithm?: DrmCertificate_Algorithm;
};

/**
 * Describes the message license_protocol.DrmCertificate.EncryptionKey.
 * Use `create(DrmCertificate_EncryptionKeySchema)` to create a new message.
 */
export const DrmCertificate_EncryptionKeySchema: GenMessage<DrmCertificate_EncryptionKey> = /*@__PURE__*/ messageDesc(file_license_protocol, 8, 0);

/**
 * @generated from enum license_protocol.DrmCertificate.Type
 */
export enum DrmCertificate_Type {
	/**
	 * ProtoBestPractices: ignore.
	 *
	 * @generated from enum value: ROOT = 0;
	 */
	ROOT = 0,

	/**
	 * @generated from enum value: DEVICE_MODEL = 1;
	 */
	DEVICE_MODEL = 1,

	/**
	 * @generated from enum value: DEVICE = 2;
	 */
	DEVICE = 2,

	/**
	 * @generated from enum value: SERVICE = 3;
	 */
	SERVICE = 3,

	/**
	 * @generated from enum value: PROVISIONER = 4;
	 */
	PROVISIONER = 4
}

/**
 * Describes the enum license_protocol.DrmCertificate.Type.
 */
export const DrmCertificate_TypeSchema: GenEnum<DrmCertificate_Type> = /*@__PURE__*/ enumDesc(file_license_protocol, 8, 0);

/**
 * @generated from enum license_protocol.DrmCertificate.ServiceType
 */
export enum DrmCertificate_ServiceType {
	/**
	 * @generated from enum value: UNKNOWN_SERVICE_TYPE = 0;
	 */
	UNKNOWN_SERVICE_TYPE = 0,

	/**
	 * @generated from enum value: LICENSE_SERVER_SDK = 1;
	 */
	LICENSE_SERVER_SDK = 1,

	/**
	 * @generated from enum value: LICENSE_SERVER_PROXY_SDK = 2;
	 */
	LICENSE_SERVER_PROXY_SDK = 2,

	/**
	 * @generated from enum value: PROVISIONING_SDK = 3;
	 */
	PROVISIONING_SDK = 3,

	/**
	 * @generated from enum value: CAS_PROXY_SDK = 4;
	 */
	CAS_PROXY_SDK = 4
}

/**
 * Describes the enum license_protocol.DrmCertificate.ServiceType.
 */
export const DrmCertificate_ServiceTypeSchema: GenEnum<DrmCertificate_ServiceType> = /*@__PURE__*/ enumDesc(file_license_protocol, 8, 1);

/**
 * @generated from enum license_protocol.DrmCertificate.Algorithm
 */
export enum DrmCertificate_Algorithm {
	/**
	 * @generated from enum value: UNKNOWN_ALGORITHM = 0;
	 */
	UNKNOWN_ALGORITHM = 0,

	/**
	 * @generated from enum value: RSA = 1;
	 */
	RSA = 1,

	/**
	 * @generated from enum value: ECC_SECP256R1 = 2;
	 */
	ECC_SECP256R1 = 2,

	/**
	 * @generated from enum value: ECC_SECP384R1 = 3;
	 */
	ECC_SECP384R1 = 3,

	/**
	 * @generated from enum value: ECC_SECP521R1 = 4;
	 */
	ECC_SECP521R1 = 4
}

/**
 * Describes the enum license_protocol.DrmCertificate.Algorithm.
 */
export const DrmCertificate_AlgorithmSchema: GenEnum<DrmCertificate_Algorithm> = /*@__PURE__*/ enumDesc(file_license_protocol, 8, 2);

/**
 * DrmCertificate signed by a higher (CA) DRM certificate.
 *
 * @generated from message license_protocol.SignedDrmCertificate
 */
export type SignedDrmCertificate = Message<'license_protocol.SignedDrmCertificate'> & {
	/**
	 * Serialized certificate. Required.
	 *
	 * @generated from field: optional bytes drm_certificate = 1;
	 */
	drmCertificate?: Uint8Array;

	/**
	 * Signature of certificate. Signed with root or intermediate
	 * certificate specified below. Required.
	 *
	 * @generated from field: optional bytes signature = 2;
	 */
	signature?: Uint8Array;

	/**
	 * SignedDrmCertificate used to sign this certificate.
	 *
	 * @generated from field: optional license_protocol.SignedDrmCertificate signer = 3;
	 */
	signer?: SignedDrmCertificate;

	/**
	 * Optional field that indicates the hash algorithm used in signature scheme.
	 *
	 * @generated from field: optional license_protocol.HashAlgorithmProto hash_algorithm = 4;
	 */
	hashAlgorithm?: HashAlgorithmProto;
};

/**
 * Describes the message license_protocol.SignedDrmCertificate.
 * Use `create(SignedDrmCertificateSchema)` to create a new message.
 */
export const SignedDrmCertificateSchema: GenMessage<SignedDrmCertificate> = /*@__PURE__*/ messageDesc(file_license_protocol, 9);

/**
 * @generated from message license_protocol.WidevinePsshData
 */
export type WidevinePsshData = Message<'license_protocol.WidevinePsshData'> & {
	/**
	 * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
	 * PSSHs. May be repeated to facilitate delivery of multiple keys in a
	 * single license. Cannot be used in conjunction with content_id or
	 * group_ids, which are the preferred mechanism.
	 *
	 * @generated from field: repeated bytes key_ids = 2;
	 */
	keyIds: Uint8Array[];

	/**
	 * Content identifier which may map to multiple entitlement or content key
	 * IDs to facilitate the delivery of multiple keys in a single license.
	 * Cannot be present in conjunction with key_ids, but if used must be in all
	 * PSSHs.
	 *
	 * @generated from field: optional bytes content_id = 4;
	 */
	contentId?: Uint8Array;

	/**
	 * Crypto period index, for media using key rotation. Always corresponds to
	 * The content key period. This means that if using entitlement licensing
	 * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
	 * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
	 * key rotation.
	 *
	 * @generated from field: optional uint32 crypto_period_index = 7;
	 */
	cryptoPeriodIndex?: number;

	/**
	 * Protection scheme identifying the encryption algorithm. The protection
	 * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
	 * representing a single ascii character in one of the 4CC protection scheme
	 * values. To be deprecated in favor of signaling from content.
	 * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
	 * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
	 * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
	 * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
	 *
	 * @generated from field: optional uint32 protection_scheme = 9;
	 */
	protectionScheme?: number;

	/**
	 * Optional. For media using key rotation, this represents the duration
	 * of each crypto period in seconds.
	 *
	 * @generated from field: optional uint32 crypto_period_seconds = 10;
	 */
	cryptoPeriodSeconds?: number;

	/**
	 * Type of PSSH. Required if not SINGLE.
	 *
	 * @generated from field: optional license_protocol.WidevinePsshData.Type type = 11;
	 */
	type?: WidevinePsshData_Type;

	/**
	 * Key sequence for Widevine-managed keys. Optional.
	 *
	 * @generated from field: optional uint32 key_sequence = 12;
	 */
	keySequence?: number;

	/**
	 * Group identifiers for all groups to which the content belongs. This can
	 * be used to deliver licenses to unlock multiple titles / channels.
	 * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
	 * not in conjunction with key_ids.
	 *
	 * @generated from field: repeated bytes group_ids = 13;
	 */
	groupIds: Uint8Array[];

	/**
	 * Copy/copies of the content key used to decrypt the media stream in which
	 * the PSSH box is embedded, each wrapped with a different entitlement key.
	 * May also contain sub-licenses to support devices with OEMCrypto 13 or
	 * older. May be repeated if using group entitlement keys. Present only in
	 * PSSHs of type ENTITLED_KEY.
	 *
	 * @generated from field: repeated license_protocol.WidevinePsshData.EntitledKey entitled_keys = 14;
	 */
	entitledKeys: WidevinePsshData_EntitledKey[];

	/**
	 * Video feature identifier, which is used in conjunction with |content_id|
	 * to determine the set of keys to be returned in the license. Cannot be
	 * present in conjunction with |key_ids|.
	 * Current values are "HDR".
	 *
	 * @generated from field: optional string video_feature = 15;
	 */
	videoFeature?: string;

	/**
	 * @generated from field: optional license_protocol.WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];
	 * @deprecated
	 */
	algorithm?: WidevinePsshData_Algorithm;

	/**
	 * Content provider name.
	 *
	 * @generated from field: optional string provider = 3 [deprecated = true];
	 * @deprecated
	 */
	provider?: string;

	/**
	 * Track type. Acceptable values are SD, HD and AUDIO. Used to
	 * differentiate content keys used by an asset.
	 *
	 * @generated from field: optional string track_type = 5 [deprecated = true];
	 * @deprecated
	 */
	trackType?: string;

	/**
	 * The name of a registered policy to be used for this asset.
	 *
	 * @generated from field: optional string policy = 6 [deprecated = true];
	 * @deprecated
	 */
	policy?: string;

	/**
	 * Optional protected context for group content. The grouped_license is a
	 * serialized SignedMessage.
	 *
	 * @generated from field: optional bytes grouped_license = 8 [deprecated = true];
	 * @deprecated
	 */
	groupedLicense?: Uint8Array;
};

/**
 * Describes the message license_protocol.WidevinePsshData.
 * Use `create(WidevinePsshDataSchema)` to create a new message.
 */
export const WidevinePsshDataSchema: GenMessage<WidevinePsshData> = /*@__PURE__*/ messageDesc(file_license_protocol, 10);

/**
 * @generated from message license_protocol.WidevinePsshData.EntitledKey
 */
export type WidevinePsshData_EntitledKey = Message<'license_protocol.WidevinePsshData.EntitledKey'> & {
	/**
	 * ID of entitlement key used for wrapping |key|.
	 *
	 * @generated from field: optional bytes entitlement_key_id = 1;
	 */
	entitlementKeyId?: Uint8Array;

	/**
	 * ID of the entitled key.
	 *
	 * @generated from field: optional bytes key_id = 2;
	 */
	keyId?: Uint8Array;

	/**
	 * Wrapped key. Required.
	 *
	 * @generated from field: optional bytes key = 3;
	 */
	key?: Uint8Array;

	/**
	 * IV used for wrapping |key|. Required.
	 *
	 * @generated from field: optional bytes iv = 4;
	 */
	iv?: Uint8Array;

	/**
	 * Size of entitlement key used for wrapping |key|.
	 *
	 * @generated from field: optional uint32 entitlement_key_size_bytes = 5;
	 */
	entitlementKeySizeBytes?: number;
};

/**
 * Describes the message license_protocol.WidevinePsshData.EntitledKey.
 * Use `create(WidevinePsshData_EntitledKeySchema)` to create a new message.
 */
export const WidevinePsshData_EntitledKeySchema: GenMessage<WidevinePsshData_EntitledKey> = /*@__PURE__*/ messageDesc(file_license_protocol, 10, 0);

/**
 * @generated from enum license_protocol.WidevinePsshData.Type
 */
export enum WidevinePsshData_Type {
	/**
	 * Single PSSH to be used to retrieve content keys.
	 *
	 * @generated from enum value: SINGLE = 0;
	 */
	SINGLE = 0,

	/**
	 * Primary PSSH used to retrieve entitlement keys.
	 *
	 * @generated from enum value: ENTITLEMENT = 1;
	 */
	ENTITLEMENT = 1,

	/**
	 * Secondary PSSH containing entitled key(s).
	 *
	 * @generated from enum value: ENTITLED_KEY = 2;
	 */
	ENTITLED_KEY = 2
}

/**
 * Describes the enum license_protocol.WidevinePsshData.Type.
 */
export const WidevinePsshData_TypeSchema: GenEnum<WidevinePsshData_Type> = /*@__PURE__*/ enumDesc(file_license_protocol, 10, 0);

/**
 * //////////////////////////  Deprecated Fields  ////////////////////////////
 *
 * @generated from enum license_protocol.WidevinePsshData.Algorithm
 */
export enum WidevinePsshData_Algorithm {
	/**
	 * @generated from enum value: UNENCRYPTED = 0;
	 */
	UNENCRYPTED = 0,

	/**
	 * @generated from enum value: AESCTR = 1;
	 */
	AESCTR = 1
}

/**
 * Describes the enum license_protocol.WidevinePsshData.Algorithm.
 */
export const WidevinePsshData_AlgorithmSchema: GenEnum<WidevinePsshData_Algorithm> = /*@__PURE__*/ enumDesc(file_license_protocol, 10, 1);

/**
 * File Hashes for Verified Media Path (VMP) support.
 *
 * @generated from message license_protocol.FileHashes
 */
export type FileHashes = Message<'license_protocol.FileHashes'> & {
	/**
	 * @generated from field: optional bytes signer = 1;
	 */
	signer?: Uint8Array;

	/**
	 * @generated from field: repeated license_protocol.FileHashes.Signature signatures = 2;
	 */
	signatures: FileHashes_Signature[];
};

/**
 * Describes the message license_protocol.FileHashes.
 * Use `create(FileHashesSchema)` to create a new message.
 */
export const FileHashesSchema: GenMessage<FileHashes> = /*@__PURE__*/ messageDesc(file_license_protocol, 11);

/**
 * @generated from message license_protocol.FileHashes.Signature
 */
export type FileHashes_Signature = Message<'license_protocol.FileHashes.Signature'> & {
	/**
	 * @generated from field: optional string filename = 1;
	 */
	filename?: string;

	/**
	 * 0 - release, 1 - testing
	 *
	 * @generated from field: optional bool test_signing = 2;
	 */
	testSigning?: boolean;

	/**
	 * @generated from field: optional bytes SHA512Hash = 3;
	 */
	SHA512Hash?: Uint8Array;

	/**
	 * 0 for dlls, 1 for exe, this is field 3 in file
	 *
	 * @generated from field: optional bool main_exe = 4;
	 */
	mainExe?: boolean;

	/**
	 * @generated from field: optional bytes signature = 5;
	 */
	signature?: Uint8Array;
};

/**
 * Describes the message license_protocol.FileHashes.Signature.
 * Use `create(FileHashes_SignatureSchema)` to create a new message.
 */
export const FileHashes_SignatureSchema: GenMessage<FileHashes_Signature> = /*@__PURE__*/ messageDesc(file_license_protocol, 11, 0);

/**
 * @generated from enum license_protocol.LicenseType
 */
export enum LicenseType {
	/**
	 * @generated from enum value: LICENSETYPE_UNVERIFIED = 0;
	 */
	LICENSETYPE_UNVERIFIED = 0,

	/**
	 * @generated from enum value: STREAMING = 1;
	 */
	STREAMING = 1,

	/**
	 * @generated from enum value: OFFLINE = 2;
	 */
	OFFLINE = 2,

	/**
	 * License type decision is left to provider.
	 *
	 * @generated from enum value: AUTOMATIC = 3;
	 */
	AUTOMATIC = 3
}

/**
 * Describes the enum license_protocol.LicenseType.
 */
export const LicenseTypeSchema: GenEnum<LicenseType> = /*@__PURE__*/ enumDesc(file_license_protocol, 0);

/**
 * @generated from enum license_protocol.PlatformVerificationStatus
 */
export enum PlatformVerificationStatus {
	/**
	 * The platform is not verified.
	 *
	 * @generated from enum value: PLATFORM_UNVERIFIED = 0;
	 */
	PLATFORM_UNVERIFIED = 0,

	/**
	 * Tampering detected on the platform.
	 *
	 * @generated from enum value: PLATFORM_TAMPERED = 1;
	 */
	PLATFORM_TAMPERED = 1,

	/**
	 * The platform has been verified by means of software.
	 *
	 * @generated from enum value: PLATFORM_SOFTWARE_VERIFIED = 2;
	 */
	PLATFORM_SOFTWARE_VERIFIED = 2,

	/**
	 * The platform has been verified by means of hardware (e.g. secure boot).
	 *
	 * @generated from enum value: PLATFORM_HARDWARE_VERIFIED = 3;
	 */
	PLATFORM_HARDWARE_VERIFIED = 3,

	/**
	 * Platform verification was not performed.
	 *
	 * @generated from enum value: PLATFORM_NO_VERIFICATION = 4;
	 */
	PLATFORM_NO_VERIFICATION = 4,

	/**
	 * Platform and secure storage capability have been verified by means of
	 * software.
	 *
	 * @generated from enum value: PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5;
	 */
	PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5
}

/**
 * Describes the enum license_protocol.PlatformVerificationStatus.
 */
export const PlatformVerificationStatusSchema: GenEnum<PlatformVerificationStatus> = /*@__PURE__*/ enumDesc(file_license_protocol, 1);

/**
 * @generated from enum license_protocol.ProtocolVersion
 */
export enum ProtocolVersion {
	/**
	 * @generated from enum value: VERSION_UNVERIFIED = 0;
	 */
	VERSION_UNVERIFIED = 0,

	/**
	 * @generated from enum value: VERSION_2_0 = 20;
	 */
	VERSION_2_0 = 20,

	/**
	 * @generated from enum value: VERSION_2_1 = 21;
	 */
	VERSION_2_1 = 21,

	/**
	 * @generated from enum value: VERSION_2_2 = 22;
	 */
	VERSION_2_2 = 22
}

/**
 * Describes the enum license_protocol.ProtocolVersion.
 */
export const ProtocolVersionSchema: GenEnum<ProtocolVersion> = /*@__PURE__*/ enumDesc(file_license_protocol, 2);

/**
 * @generated from enum license_protocol.HashAlgorithmProto
 */
export enum HashAlgorithmProto {
	/**
	 * Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
	 * and SHA_1 shall be used otherwise.
	 *
	 * @generated from enum value: HASH_ALGORITHM_UNSPECIFIED = 0;
	 */
	HASH_ALGORITHM_UNSPECIFIED = 0,

	/**
	 * @generated from enum value: HASH_ALGORITHM_SHA_1 = 1;
	 */
	HASH_ALGORITHM_SHA_1 = 1,

	/**
	 * @generated from enum value: HASH_ALGORITHM_SHA_256 = 2;
	 */
	HASH_ALGORITHM_SHA_256 = 2,

	/**
	 * @generated from enum value: HASH_ALGORITHM_SHA_384 = 3;
	 */
	HASH_ALGORITHM_SHA_384 = 3
}

/**
 * Describes the enum license_protocol.HashAlgorithmProto.
 */
export const HashAlgorithmProtoSchema: GenEnum<HashAlgorithmProto> = /*@__PURE__*/ enumDesc(file_license_protocol, 3);
