// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file license_protocol.proto (package license_protocol, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from '@bufbuild/protobuf/codegenv1';
import { enumDesc, fileDesc, messageDesc } from '@bufbuild/protobuf/codegenv1';
import type { Message } from '@bufbuild/protobuf';

/**
 * Describes the file license_protocol.proto.
 */
export const file_license_protocol: GenFile =
  /*@__PURE__*/
  fileDesc(
    'ChZsaWNlbnNlX3Byb3RvY29sLnByb3RvEhBsaWNlbnNlX3Byb3RvY29sIq4CChVMaWNlbnNlSWRlbnRpZmljYXRpb24SFwoKcmVxdWVzdF9pZBgBIAEoDEgAiAEBEhcKCnNlc3Npb25faWQYAiABKAxIAYgBARIYCgtwdXJjaGFzZV9pZBgDIAEoDEgCiAEBEjAKBHR5cGUYBCABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSAOIAQESFAoHdmVyc2lvbhgFIAEoBUgEiAEBEiMKFnByb3ZpZGVyX3Nlc3Npb25fdG9rZW4YBiABKAxIBYgBAUINCgtfcmVxdWVzdF9pZEINCgtfc2Vzc2lvbl9pZEIOCgxfcHVyY2hhc2VfaWRCBwoFX3R5cGVCCgoIX3ZlcnNpb25CGQoXX3Byb3ZpZGVyX3Nlc3Npb25fdG9rZW4izCAKB0xpY2Vuc2USOAoCaWQYASABKAsyJy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VJZGVudGlmaWNhdGlvbkgAiAEBEjUKBnBvbGljeRgCIAEoCzIgLmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZS5Qb2xpY3lIAYgBARIzCgNrZXkYAyADKAsyJi5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyEh8KEmxpY2Vuc2Vfc3RhcnRfdGltZRgEIAEoA0gCiAEBEigKG3JlbW90ZV9hdHRlc3RhdGlvbl92ZXJpZmllZBgFIAEoCEgDiAEBEiIKFXByb3ZpZGVyX2NsaWVudF90b2tlbhgGIAEoDEgEiAEBEh4KEXByb3RlY3Rpb25fc2NoZW1lGAcgASgNSAWIAQESHAoPc3JtX3JlcXVpcmVtZW50GAggASgMSAaIAQESFwoKc3JtX3VwZGF0ZRgJIAEoDEgHiAEBElcKHHBsYXRmb3JtX3ZlcmlmaWNhdGlvbl9zdGF0dXMYCiABKA4yLC5saWNlbnNlX3Byb3RvY29sLlBsYXRmb3JtVmVyaWZpY2F0aW9uU3RhdHVzSAiIAQESEQoJZ3JvdXBfaWRzGAsgAygMGsoHCgZQb2xpY3kSFQoIY2FuX3BsYXkYASABKAhIAIgBARIYCgtjYW5fcGVyc2lzdBgCIAEoCEgBiAEBEhYKCWNhbl9yZW5ldxgDIAEoCEgCiAEBEiQKF3JlbnRhbF9kdXJhdGlvbl9zZWNvbmRzGAQgASgDSAOIAQESJgoZcGxheWJhY2tfZHVyYXRpb25fc2Vjb25kcxgFIAEoA0gEiAEBEiUKGGxpY2Vuc2VfZHVyYXRpb25fc2Vjb25kcxgGIAEoA0gFiAEBEi4KIXJlbmV3YWxfcmVjb3ZlcnlfZHVyYXRpb25fc2Vjb25kcxgHIAEoA0gGiAEBEh8KEnJlbmV3YWxfc2VydmVyX3VybBgIIAEoCUgHiAEBEiIKFXJlbmV3YWxfZGVsYXlfc2Vjb25kcxgJIAEoA0gIiAEBEisKHnJlbmV3YWxfcmV0cnlfaW50ZXJ2YWxfc2Vjb25kcxgKIAEoA0gJiAEBEh0KEHJlbmV3X3dpdGhfdXNhZ2UYCyABKAhICogBARIlChhhbHdheXNfaW5jbHVkZV9jbGllbnRfaWQYDCABKAhIC4gBARIsCh9wbGF5X3N0YXJ0X2dyYWNlX3BlcmlvZF9zZWNvbmRzGA0gASgDSAyIAQESKwoec29mdF9lbmZvcmNlX3BsYXliYWNrX2R1cmF0aW9uGA4gASgISA2IAQESKQocc29mdF9lbmZvcmNlX3JlbnRhbF9kdXJhdGlvbhgPIAEoCEgOiAEBQgsKCV9jYW5fcGxheUIOCgxfY2FuX3BlcnNpc3RCDAoKX2Nhbl9yZW5ld0IaChhfcmVudGFsX2R1cmF0aW9uX3NlY29uZHNCHAoaX3BsYXliYWNrX2R1cmF0aW9uX3NlY29uZHNCGwoZX2xpY2Vuc2VfZHVyYXRpb25fc2Vjb25kc0IkCiJfcmVuZXdhbF9yZWNvdmVyeV9kdXJhdGlvbl9zZWNvbmRzQhUKE19yZW5ld2FsX3NlcnZlcl91cmxCGAoWX3JlbmV3YWxfZGVsYXlfc2Vjb25kc0IhCh9fcmVuZXdhbF9yZXRyeV9pbnRlcnZhbF9zZWNvbmRzQhMKEV9yZW5ld193aXRoX3VzYWdlQhsKGV9hbHdheXNfaW5jbHVkZV9jbGllbnRfaWRCIgogX3BsYXlfc3RhcnRfZ3JhY2VfcGVyaW9kX3NlY29uZHNCIQofX3NvZnRfZW5mb3JjZV9wbGF5YmFja19kdXJhdGlvbkIfCh1fc29mdF9lbmZvcmNlX3JlbnRhbF9kdXJhdGlvbhreEwoMS2V5Q29udGFpbmVyEg8KAmlkGAEgASgMSACIAQESDwoCaXYYAiABKAxIAYgBARIQCgNrZXkYAyABKAxIAogBARJBCgR0eXBlGAQgASgOMi4ubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5LZXlUeXBlSAOIAQESSAoFbGV2ZWwYBSABKA4yNC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyLlNlY3VyaXR5TGV2ZWxIBIgBARJZChNyZXF1aXJlZF9wcm90ZWN0aW9uGAYgASgLMjcubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uSAWIAQESWgoUcmVxdWVzdGVkX3Byb3RlY3Rpb24YByABKAsyNy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyLk91dHB1dFByb3RlY3Rpb25IBogBARJLCgtrZXlfY29udHJvbBgIIAEoCzIxLmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZS5LZXlDb250YWluZXIuS2V5Q29udHJvbEgHiAEBEnMKIG9wZXJhdG9yX3Nlc3Npb25fa2V5X3Blcm1pc3Npb25zGAkgASgLMkQubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PcGVyYXRvclNlc3Npb25LZXlQZXJtaXNzaW9uc0gIiAEBEmYKHHZpZGVvX3Jlc29sdXRpb25fY29uc3RyYWludHMYCiADKAsyQC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2UuS2V5Q29udGFpbmVyLlZpZGVvUmVzb2x1dGlvbkNvbnN0cmFpbnQSJgoZYW50aV9yb2xsYmFja191c2FnZV90YWJsZRgLIAEoCEgJiAEBEhgKC3RyYWNrX2xhYmVsGAwgASgJSAqIAQEaWgoKS2V5Q29udHJvbBIeChFrZXlfY29udHJvbF9ibG9jaxgBIAEoDEgAiAEBEg8KAml2GAIgASgMSAGIAQFCFAoSX2tleV9jb250cm9sX2Jsb2NrQgUKA19pdhq7BQoQT3V0cHV0UHJvdGVjdGlvbhJPCgRoZGNwGAEgASgOMjwubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkhEQ1BIAIgBARJVCgpjZ21zX2ZsYWdzGAIgASgOMjwubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkNHTVNIAYgBARJfCg1oZGNwX3NybV9ydWxlGAMgASgOMkMubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uLkhkY3BTcm1SdWxlSAKIAQESIgoVZGlzYWJsZV9hbmFsb2dfb3V0cHV0GAQgASgISAOIAQESIwoWZGlzYWJsZV9kaWdpdGFsX291dHB1dBgFIAEoCEgEiAEBInkKBEhEQ1ASDQoJSERDUF9OT05FEAASCwoHSERDUF9WMRABEgsKB0hEQ1BfVjIQAhINCglIRENQX1YyXzEQAxINCglIRENQX1YyXzIQBBINCglIRENQX1YyXzMQBRIbChZIRENQX05PX0RJR0lUQUxfT1VUUFVUEP8BIkMKBENHTVMSDQoJQ09QWV9GUkVFEAASDQoJQ0dNU19OT05FECoSDQoJQ09QWV9PTkNFEAISDgoKQ09QWV9ORVZFUhADIjYKC0hkY3BTcm1SdWxlEhYKEkhEQ1BfU1JNX1JVTEVfTk9ORRAAEg8KC0NVUlJFTlRfU1JNEAFCBwoFX2hkY3BCDQoLX2NnbXNfZmxhZ3NCEAoOX2hkY3Bfc3JtX3J1bGVCGAoWX2Rpc2FibGVfYW5hbG9nX291dHB1dEIZChdfZGlzYWJsZV9kaWdpdGFsX291dHB1dBqKAgoZVmlkZW9SZXNvbHV0aW9uQ29uc3RyYWludBIiChVtaW5fcmVzb2x1dGlvbl9waXhlbHMYASABKA1IAIgBARIiChVtYXhfcmVzb2x1dGlvbl9waXhlbHMYAiABKA1IAYgBARJZChNyZXF1aXJlZF9wcm90ZWN0aW9uGAMgASgLMjcubGljZW5zZV9wcm90b2NvbC5MaWNlbnNlLktleUNvbnRhaW5lci5PdXRwdXRQcm90ZWN0aW9uSAKIAQFCGAoWX21pbl9yZXNvbHV0aW9uX3BpeGVsc0IYChZfbWF4X3Jlc29sdXRpb25fcGl4ZWxzQhYKFF9yZXF1aXJlZF9wcm90ZWN0aW9uGuMBCh1PcGVyYXRvclNlc3Npb25LZXlQZXJtaXNzaW9ucxIaCg1hbGxvd19lbmNyeXB0GAEgASgISACIAQESGgoNYWxsb3dfZGVjcnlwdBgCIAEoCEgBiAEBEhcKCmFsbG93X3NpZ24YAyABKAhIAogBARIjChZhbGxvd19zaWduYXR1cmVfdmVyaWZ5GAQgASgISAOIAQFCEAoOX2FsbG93X2VuY3J5cHRCEAoOX2FsbG93X2RlY3J5cHRCDQoLX2FsbG93X3NpZ25CGQoXX2FsbG93X3NpZ25hdHVyZV92ZXJpZnkihAEKB0tleVR5cGUSFgoSS0VZVFlQRV9VTlZFUklGSUVEEAASCwoHU0lHTklORxABEgsKB0NPTlRFTlQQAhIPCgtLRVlfQ09OVFJPTBADEhQKEE9QRVJBVE9SX1NFU1NJT04QBBIPCgtFTlRJVExFTUVOVBAFEg8KC09FTV9DT05URU5UEAYimAEKDVNlY3VyaXR5TGV2ZWwSHAoYU0VDVVJJVFlMRVZFTF9VTlZFUklGSUVEEAASFAoQU1dfU0VDVVJFX0NSWVBUTxABEhQKEFNXX1NFQ1VSRV9ERUNPREUQAhIUChBIV19TRUNVUkVfQ1JZUFRPEAMSFAoQSFdfU0VDVVJFX0RFQ09ERRAEEhEKDUhXX1NFQ1VSRV9BTEwQBUIFCgNfaWRCBQoDX2l2QgYKBF9rZXlCBwoFX3R5cGVCCAoGX2xldmVsQhYKFF9yZXF1aXJlZF9wcm90ZWN0aW9uQhcKFV9yZXF1ZXN0ZWRfcHJvdGVjdGlvbkIOCgxfa2V5X2NvbnRyb2xCIwohX29wZXJhdG9yX3Nlc3Npb25fa2V5X3Blcm1pc3Npb25zQhwKGl9hbnRpX3JvbGxiYWNrX3VzYWdlX3RhYmxlQg4KDF90cmFja19sYWJlbEIFCgNfaWRCCQoHX3BvbGljeUIVChNfbGljZW5zZV9zdGFydF90aW1lQh4KHF9yZW1vdGVfYXR0ZXN0YXRpb25fdmVyaWZpZWRCGAoWX3Byb3ZpZGVyX2NsaWVudF90b2tlbkIUChJfcHJvdGVjdGlvbl9zY2hlbWVCEgoQX3NybV9yZXF1aXJlbWVudEINCgtfc3JtX3VwZGF0ZUIfCh1fcGxhdGZvcm1fdmVyaWZpY2F0aW9uX3N0YXR1cyLAEAoOTGljZW5zZVJlcXVlc3QSPgoJY2xpZW50X2lkGAEgASgLMiYubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbkgAiAEBEk8KCmNvbnRlbnRfaWQYAiABKAsyNi5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbkgBiAEBEj8KBHR5cGUYAyABKA4yLC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LlJlcXVlc3RUeXBlSAKIAQESGQoMcmVxdWVzdF90aW1lGAQgASgDSAOIAQESKQoca2V5X2NvbnRyb2xfbm9uY2VfZGVwcmVjYXRlZBgFIAEoDEgEiAEBEkAKEHByb3RvY29sX3ZlcnNpb24YBiABKA4yIS5saWNlbnNlX3Byb3RvY29sLlByb3RvY29sVmVyc2lvbkgFiAEBEh4KEWtleV9jb250cm9sX25vbmNlGAcgASgNSAaIAQESUQoTZW5jcnlwdGVkX2NsaWVudF9pZBgIIAEoCzIvLmxpY2Vuc2VfcHJvdG9jb2wuRW5jcnlwdGVkQ2xpZW50SWRlbnRpZmljYXRpb25IB4gBARr3CgoVQ29udGVudElkZW50aWZpY2F0aW9uEmUKEndpZGV2aW5lX3Bzc2hfZGF0YRgBIAEoCzJHLmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZVJlcXVlc3QuQ29udGVudElkZW50aWZpY2F0aW9uLldpZGV2aW5lUHNzaERhdGFIABJXCgt3ZWJtX2tleV9pZBgCIAEoCzJALmxpY2Vuc2VfcHJvdG9jb2wuTGljZW5zZVJlcXVlc3QuQ29udGVudElkZW50aWZpY2F0aW9uLldlYm1LZXlJZEgAEmIKEGV4aXN0aW5nX2xpY2Vuc2UYAyABKAsyRi5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5FeGlzdGluZ0xpY2Vuc2VIABJUCglpbml0X2RhdGEYBCABKAsyPy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5Jbml0RGF0YUgAGpgBChBXaWRldmluZVBzc2hEYXRhEhEKCXBzc2hfZGF0YRgBIAMoDBI4CgxsaWNlbnNlX3R5cGUYAiABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSACIAQESFwoKcmVxdWVzdF9pZBgDIAEoDEgBiAEBQg8KDV9saWNlbnNlX3R5cGVCDQoLX3JlcXVlc3RfaWQangEKCVdlYm1LZXlJZBITCgZoZWFkZXIYASABKAxIAIgBARI4CgxsaWNlbnNlX3R5cGUYAiABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSAGIAQESFwoKcmVxdWVzdF9pZBgDIAEoDEgCiAEBQgkKB19oZWFkZXJCDwoNX2xpY2Vuc2VfdHlwZUINCgtfcmVxdWVzdF9pZBqsAgoPRXhpc3RpbmdMaWNlbnNlEkAKCmxpY2Vuc2VfaWQYASABKAsyJy5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VJZGVudGlmaWNhdGlvbkgAiAEBEiIKFXNlY29uZHNfc2luY2Vfc3RhcnRlZBgCIAEoA0gBiAEBEiYKGXNlY29uZHNfc2luY2VfbGFzdF9wbGF5ZWQYAyABKANIAogBARImChlzZXNzaW9uX3VzYWdlX3RhYmxlX2VudHJ5GAQgASgMSAOIAQFCDQoLX2xpY2Vuc2VfaWRCGAoWX3NlY29uZHNfc2luY2Vfc3RhcnRlZEIcChpfc2Vjb25kc19zaW5jZV9sYXN0X3BsYXllZEIcChpfc2Vzc2lvbl91c2FnZV90YWJsZV9lbnRyeRriAgoISW5pdERhdGESaQoOaW5pdF9kYXRhX3R5cGUYASABKA4yTC5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VSZXF1ZXN0LkNvbnRlbnRJZGVudGlmaWNhdGlvbi5Jbml0RGF0YS5Jbml0RGF0YVR5cGVIAIgBARIWCglpbml0X2RhdGEYAiABKAxIAYgBARI4CgxsaWNlbnNlX3R5cGUYAyABKA4yHS5saWNlbnNlX3Byb3RvY29sLkxpY2Vuc2VUeXBlSAKIAQESFwoKcmVxdWVzdF9pZBgEIAEoDEgDiAEBIj8KDEluaXREYXRhVHlwZRIbChdJTklUREFUQVRZUEVfVU5WRVJJRklFRBAAEggKBENFTkMQARIICgRXRUJNEAJCEQoPX2luaXRfZGF0YV90eXBlQgwKCl9pbml0X2RhdGFCDwoNX2xpY2Vuc2VfdHlwZUINCgtfcmVxdWVzdF9pZEIUChJjb250ZW50X2lkX3ZhcmlhbnQiTAoLUmVxdWVzdFR5cGUSGgoWUkVRVUVTVFRZUEVfVU5WRVJJRklFRBAAEgcKA05FVxABEgsKB1JFTkVXQUwQAhILCgdSRUxFQVNFEANCDAoKX2NsaWVudF9pZEINCgtfY29udGVudF9pZEIHCgVfdHlwZUIPCg1fcmVxdWVzdF90aW1lQh8KHV9rZXlfY29udHJvbF9ub25jZV9kZXByZWNhdGVkQhMKEV9wcm90b2NvbF92ZXJzaW9uQhQKEl9rZXlfY29udHJvbF9ub25jZUIWChRfZW5jcnlwdGVkX2NsaWVudF9pZCKmAgoKTWV0cmljRGF0YRIXCgpzdGFnZV9uYW1lGAEgASgJSACIAQESOwoLbWV0cmljX2RhdGEYAiADKAsyJi5saWNlbnNlX3Byb3RvY29sLk1ldHJpY0RhdGEuVHlwZVZhbHVlGm4KCVR5cGVWYWx1ZRI6CgR0eXBlGAEgASgOMicubGljZW5zZV9wcm90b2NvbC5NZXRyaWNEYXRhLk1ldHJpY1R5cGVIAIgBARISCgV2YWx1ZRgCIAEoA0gBiAEBQgcKBV90eXBlQggKBl92YWx1ZSJDCgpNZXRyaWNUeXBlEhkKFU1FVFJJQ1RZUEVfVU5WRVJJRklFRBAAEgsKB0xBVEVOQ1kQARINCglUSU1FU1RBTVAQAkINCgtfc3RhZ2VfbmFtZSKJAQoLVmVyc2lvbkluZm8SIAoTbGljZW5zZV9zZGtfdmVyc2lvbhgBIAEoCUgAiAEBEiQKF2xpY2Vuc2Vfc2VydmljZV92ZXJzaW9uGAIgASgJSAGIAQFCFgoUX2xpY2Vuc2Vfc2RrX3ZlcnNpb25CGgoYX2xpY2Vuc2Vfc2VydmljZV92ZXJzaW9uIowHCg1TaWduZWRNZXNzYWdlEj4KBHR5cGUYASABKA4yKy5saWNlbnNlX3Byb3RvY29sLlNpZ25lZE1lc3NhZ2UuTWVzc2FnZVR5cGVIAIgBARIQCgNtc2cYAiABKAxIAYgBARIWCglzaWduYXR1cmUYAyABKAxIAogBARIYCgtzZXNzaW9uX2tleRgEIAEoDEgDiAEBEh8KEnJlbW90ZV9hdHRlc3RhdGlvbhgFIAEoDEgEiAEBEjEKC21ldHJpY19kYXRhGAYgAygLMhwubGljZW5zZV9wcm90b2NvbC5NZXRyaWNEYXRhEkAKFHNlcnZpY2VfdmVyc2lvbl9pbmZvGAcgASgLMh0ubGljZW5zZV9wcm90b2NvbC5WZXJzaW9uSW5mb0gFiAEBEk0KEHNlc3Npb25fa2V5X3R5cGUYCCABKA4yLi5saWNlbnNlX3Byb3RvY29sLlNpZ25lZE1lc3NhZ2UuU2Vzc2lvbktleVR5cGVIBogBARIjChZvZW1jcnlwdG9fY29yZV9tZXNzYWdlGAkgASgMSAeIAQEiiAIKC01lc3NhZ2VUeXBlEhoKFk1FU1NBR0VUWVBFX1VOVkVSSUZJRUQQABITCg9MSUNFTlNFX1JFUVVFU1QQARILCgdMSUNFTlNFEAISEgoORVJST1JfUkVTUE9OU0UQAxIfChtTRVJWSUNFX0NFUlRJRklDQVRFX1JFUVVFU1QQBBIXChNTRVJWSUNFX0NFUlRJRklDQVRFEAUSDwoLU1VCX0xJQ0VOU0UQBhIXChNDQVNfTElDRU5TRV9SRVFVRVNUEAcSDwoLQ0FTX0xJQ0VOU0UQCBIcChhFWFRFUk5BTF9MSUNFTlNFX1JFUVVFU1QQCRIUChBFWFRFUk5BTF9MSUNFTlNFEAoiUwoOU2Vzc2lvbktleVR5cGUSDQoJVU5ERUZJTkVEEAASEwoPV1JBUFBFRF9BRVNfS0VZEAESHQoZRVBIRVJNRVJBTF9FQ0NfUFVCTElDX0tFWRACQgcKBV90eXBlQgYKBF9tc2dCDAoKX3NpZ25hdHVyZUIOCgxfc2Vzc2lvbl9rZXlCFQoTX3JlbW90ZV9hdHRlc3RhdGlvbkIXChVfc2VydmljZV92ZXJzaW9uX2luZm9CEwoRX3Nlc3Npb25fa2V5X3R5cGVCGQoXX29lbWNyeXB0b19jb3JlX21lc3NhZ2UijxEKFENsaWVudElkZW50aWZpY2F0aW9uEkMKBHR5cGUYASABKA4yMC5saWNlbnNlX3Byb3RvY29sLkNsaWVudElkZW50aWZpY2F0aW9uLlRva2VuVHlwZUgAiAEBEhIKBXRva2VuGAIgASgMSAGIAQESRQoLY2xpZW50X2luZm8YAyADKAsyMC5saWNlbnNlX3Byb3RvY29sLkNsaWVudElkZW50aWZpY2F0aW9uLk5hbWVWYWx1ZRIiChVwcm92aWRlcl9jbGllbnRfdG9rZW4YBCABKAxIAogBARIcCg9saWNlbnNlX2NvdW50ZXIYBSABKA1IA4gBARJbChNjbGllbnRfY2FwYWJpbGl0aWVzGAYgASgLMjkubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXNIBIgBARIVCgh2bXBfZGF0YRgHIAEoDEgFiAEBElQKEmRldmljZV9jcmVkZW50aWFscxgIIAMoCzI4LmxpY2Vuc2VfcHJvdG9jb2wuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q3JlZGVudGlhbHMaRQoJTmFtZVZhbHVlEhEKBG5hbWUYASABKAlIAIgBARISCgV2YWx1ZRgCIAEoCUgBiAEBQgcKBV9uYW1lQggKBl92YWx1ZRqnCgoSQ2xpZW50Q2FwYWJpbGl0aWVzEhkKDGNsaWVudF90b2tlbhgBIAEoCEgAiAEBEhoKDXNlc3Npb25fdG9rZW4YAiABKAhIAYgBARIpChx2aWRlb19yZXNvbHV0aW9uX2NvbnN0cmFpbnRzGAMgASgISAKIAQESZAoQbWF4X2hkY3BfdmVyc2lvbhgEIAEoDjJFLmxpY2Vuc2VfcHJvdG9jb2wuQ2xpZW50SWRlbnRpZmljYXRpb24uQ2xpZW50Q2FwYWJpbGl0aWVzLkhkY3BWZXJzaW9uSAOIAQESIwoWb2VtX2NyeXB0b19hcGlfdmVyc2lvbhgFIAEoDUgEiAEBEiYKGWFudGlfcm9sbGJhY2tfdXNhZ2VfdGFibGUYBiABKAhIBYgBARIYCgtzcm1fdmVyc2lvbhgHIAEoDUgGiAEBEhsKDmNhbl91cGRhdGVfc3JtGAggASgISAeIAQESdAoec3VwcG9ydGVkX2NlcnRpZmljYXRlX2tleV90eXBlGAkgAygOMkwubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXMuQ2VydGlmaWNhdGVLZXlUeXBlEnsKGmFuYWxvZ19vdXRwdXRfY2FwYWJpbGl0aWVzGAogASgOMlIubGljZW5zZV9wcm90b2NvbC5DbGllbnRJZGVudGlmaWNhdGlvbi5DbGllbnRDYXBhYmlsaXRpZXMuQW5hbG9nT3V0cHV0Q2FwYWJpbGl0aWVzSAiIAQESJgoZY2FuX2Rpc2FibGVfYW5hbG9nX291dHB1dBgLIAEoCEgJiAEBEiEKFHJlc291cmNlX3JhdGluZ190aWVyGAwgASgNSAqIAQEigAEKC0hkY3BWZXJzaW9uEg0KCUhEQ1BfTk9ORRAAEgsKB0hEQ1BfVjEQARILCgdIRENQX1YyEAISDQoJSERDUF9WMl8xEAMSDQoJSERDUF9WMl8yEAQSDQoJSERDUF9WMl8zEAUSGwoWSERDUF9OT19ESUdJVEFMX09VVFBVVBD/ASJpChJDZXJ0aWZpY2F0ZUtleVR5cGUSDAoIUlNBXzIwNDgQABIMCghSU0FfMzA3MhABEhEKDUVDQ19TRUNQMjU2UjEQAhIRCg1FQ0NfU0VDUDM4NFIxEAMSEQoNRUNDX1NFQ1A1MjFSMRAEIo0BChhBbmFsb2dPdXRwdXRDYXBhYmlsaXRpZXMSGQoVQU5BTE9HX09VVFBVVF9VTktOT1dOEAASFgoSQU5BTE9HX09VVFBVVF9OT05FEAESGwoXQU5BTE9HX09VVFBVVF9TVVBQT1JURUQQAhIhCh1BTkFMT0dfT1VUUFVUX1NVUFBPUlRTX0NHTVNfQRADQg8KDV9jbGllbnRfdG9rZW5CEAoOX3Nlc3Npb25fdG9rZW5CHwodX3ZpZGVvX3Jlc29sdXRpb25fY29uc3RyYWludHNCEwoRX21heF9oZGNwX3ZlcnNpb25CGQoXX29lbV9jcnlwdG9fYXBpX3ZlcnNpb25CHAoaX2FudGlfcm9sbGJhY2tfdXNhZ2VfdGFibGVCDgoMX3NybV92ZXJzaW9uQhEKD19jYW5fdXBkYXRlX3NybUIdChtfYW5hbG9nX291dHB1dF9jYXBhYmlsaXRpZXNCHAoaX2Nhbl9kaXNhYmxlX2FuYWxvZ19vdXRwdXRCFwoVX3Jlc291cmNlX3JhdGluZ190aWVyGn8KEUNsaWVudENyZWRlbnRpYWxzEkMKBHR5cGUYASABKA4yMC5saWNlbnNlX3Byb3RvY29sLkNsaWVudElkZW50aWZpY2F0aW9uLlRva2VuVHlwZUgAiAEBEhIKBXRva2VuGAIgASgMSAGIAQFCBwoFX3R5cGVCCAoGX3Rva2VuInMKCVRva2VuVHlwZRIKCgZLRVlCT1gQABIaChZEUk1fREVWSUNFX0NFUlRJRklDQVRFEAESIgoeUkVNT1RFX0FUVEVTVEFUSU9OX0NFUlRJRklDQVRFEAISGgoWT0VNX0RFVklDRV9DRVJUSUZJQ0FURRADQgcKBV90eXBlQggKBl90b2tlbkIYChZfcHJvdmlkZXJfY2xpZW50X3Rva2VuQhIKEF9saWNlbnNlX2NvdW50ZXJCFgoUX2NsaWVudF9jYXBhYmlsaXRpZXNCCwoJX3ZtcF9kYXRhItcCCh1FbmNyeXB0ZWRDbGllbnRJZGVudGlmaWNhdGlvbhIYCgtwcm92aWRlcl9pZBgBIAEoCUgAiAEBEi4KIXNlcnZpY2VfY2VydGlmaWNhdGVfc2VyaWFsX251bWJlchgCIAEoDEgBiAEBEiAKE2VuY3J5cHRlZF9jbGllbnRfaWQYAyABKAxIAogBARIjChZlbmNyeXB0ZWRfY2xpZW50X2lkX2l2GAQgASgMSAOIAQESIgoVZW5jcnlwdGVkX3ByaXZhY3lfa2V5GAUgASgMSASIAQFCDgoMX3Byb3ZpZGVyX2lkQiQKIl9zZXJ2aWNlX2NlcnRpZmljYXRlX3NlcmlhbF9udW1iZXJCFgoUX2VuY3J5cHRlZF9jbGllbnRfaWRCGQoXX2VuY3J5cHRlZF9jbGllbnRfaWRfaXZCGAoWX2VuY3J5cHRlZF9wcml2YWN5X2tleSKdCQoORHJtQ2VydGlmaWNhdGUSOAoEdHlwZRgBIAEoDjIlLmxpY2Vuc2VfcHJvdG9jb2wuRHJtQ2VydGlmaWNhdGUuVHlwZUgAiAEBEhoKDXNlcmlhbF9udW1iZXIYAiABKAxIAYgBARIiChVjcmVhdGlvbl90aW1lX3NlY29uZHMYAyABKA1IAogBARIkChdleHBpcmF0aW9uX3RpbWVfc2Vjb25kcxgMIAEoDUgDiAEBEhcKCnB1YmxpY19rZXkYBCABKAxIBIgBARIWCglzeXN0ZW1faWQYBSABKA1IBYgBARInChZ0ZXN0X2RldmljZV9kZXByZWNhdGVkGAYgASgIQgIYAUgGiAEBEhgKC3Byb3ZpZGVyX2lkGAcgASgJSAeIAQESQwoNc2VydmljZV90eXBlcxgIIAMoDjIsLmxpY2Vuc2VfcHJvdG9jb2wuRHJtQ2VydGlmaWNhdGUuU2VydmljZVR5cGUSQgoJYWxnb3JpdGhtGAkgASgOMioubGljZW5zZV9wcm90b2NvbC5Ecm1DZXJ0aWZpY2F0ZS5BbGdvcml0aG1ICIgBARITCgZyb3RfaWQYCiABKAxICYgBARJLCg5lbmNyeXB0aW9uX2tleRgLIAEoCzIuLmxpY2Vuc2VfcHJvdG9jb2wuRHJtQ2VydGlmaWNhdGUuRW5jcnlwdGlvbktleUgKiAEBGokBCg1FbmNyeXB0aW9uS2V5EhcKCnB1YmxpY19rZXkYASABKAxIAIgBARJCCglhbGdvcml0aG0YAiABKA4yKi5saWNlbnNlX3Byb3RvY29sLkRybUNlcnRpZmljYXRlLkFsZ29yaXRobUgBiAEBQg0KC19wdWJsaWNfa2V5QgwKCl9hbGdvcml0aG0iTAoEVHlwZRIICgRST09UEAASEAoMREVWSUNFX01PREVMEAESCgoGREVWSUNFEAISCwoHU0VSVklDRRADEg8KC1BST1ZJU0lPTkVSEAQihgEKC1NlcnZpY2VUeXBlEhgKFFVOS05PV05fU0VSVklDRV9UWVBFEAASFgoSTElDRU5TRV9TRVJWRVJfU0RLEAESHAoYTElDRU5TRV9TRVJWRVJfUFJPWFlfU0RLEAISFAoQUFJPVklTSU9OSU5HX1NESxADEhEKDUNBU19QUk9YWV9TREsQBCJkCglBbGdvcml0aG0SFQoRVU5LTk9XTl9BTEdPUklUSE0QABIHCgNSU0EQARIRCg1FQ0NfU0VDUDI1NlIxEAISEQoNRUNDX1NFQ1AzODRSMRADEhEKDUVDQ19TRUNQNTIxUjEQBEIHCgVfdHlwZUIQCg5fc2VyaWFsX251bWJlckIYChZfY3JlYXRpb25fdGltZV9zZWNvbmRzQhoKGF9leHBpcmF0aW9uX3RpbWVfc2Vjb25kc0INCgtfcHVibGljX2tleUIMCgpfc3lzdGVtX2lkQhkKF190ZXN0X2RldmljZV9kZXByZWNhdGVkQg4KDF9wcm92aWRlcl9pZEIMCgpfYWxnb3JpdGhtQgkKB19yb3RfaWRCEQoPX2VuY3J5cHRpb25fa2V5IowCChRTaWduZWREcm1DZXJ0aWZpY2F0ZRIcCg9kcm1fY2VydGlmaWNhdGUYASABKAxIAIgBARIWCglzaWduYXR1cmUYAiABKAxIAYgBARI7CgZzaWduZXIYAyABKAsyJi5saWNlbnNlX3Byb3RvY29sLlNpZ25lZERybUNlcnRpZmljYXRlSAKIAQESQQoOaGFzaF9hbGdvcml0aG0YBCABKA4yJC5saWNlbnNlX3Byb3RvY29sLkhhc2hBbGdvcml0aG1Qcm90b0gDiAEBQhIKEF9kcm1fY2VydGlmaWNhdGVCDAoKX3NpZ25hdHVyZUIJCgdfc2lnbmVyQhEKD19oYXNoX2FsZ29yaXRobSK7CAoQV2lkZXZpbmVQc3NoRGF0YRIPCgdrZXlfaWRzGAIgAygMEhcKCmNvbnRlbnRfaWQYBCABKAxIAIgBARIgChNjcnlwdG9fcGVyaW9kX2luZGV4GAcgASgNSAGIAQESHgoRcHJvdGVjdGlvbl9zY2hlbWUYCSABKA1IAogBARIiChVjcnlwdG9fcGVyaW9kX3NlY29uZHMYCiABKA1IA4gBARI6CgR0eXBlGAsgASgOMicubGljZW5zZV9wcm90b2NvbC5XaWRldmluZVBzc2hEYXRhLlR5cGVIBIgBARIZCgxrZXlfc2VxdWVuY2UYDCABKA1IBYgBARIRCglncm91cF9pZHMYDSADKAwSRQoNZW50aXRsZWRfa2V5cxgOIAMoCzIuLmxpY2Vuc2VfcHJvdG9jb2wuV2lkZXZpbmVQc3NoRGF0YS5FbnRpdGxlZEtleRIaCg12aWRlb19mZWF0dXJlGA8gASgJSAaIAQESSAoJYWxnb3JpdGhtGAEgASgOMiwubGljZW5zZV9wcm90b2NvbC5XaWRldmluZVBzc2hEYXRhLkFsZ29yaXRobUICGAFIB4gBARIZCghwcm92aWRlchgDIAEoCUICGAFICIgBARIbCgp0cmFja190eXBlGAUgASgJQgIYAUgJiAEBEhcKBnBvbGljeRgGIAEoCUICGAFICogBARIgCg9ncm91cGVkX2xpY2Vuc2UYCCABKAxCAhgBSAuIAQEa3wEKC0VudGl0bGVkS2V5Eh8KEmVudGl0bGVtZW50X2tleV9pZBgBIAEoDEgAiAEBEhMKBmtleV9pZBgCIAEoDEgBiAEBEhAKA2tleRgDIAEoDEgCiAEBEg8KAml2GAQgASgMSAOIAQESJwoaZW50aXRsZW1lbnRfa2V5X3NpemVfYnl0ZXMYBSABKA1IBIgBAUIVChNfZW50aXRsZW1lbnRfa2V5X2lkQgkKB19rZXlfaWRCBgoEX2tleUIFCgNfaXZCHQobX2VudGl0bGVtZW50X2tleV9zaXplX2J5dGVzIjUKBFR5cGUSCgoGU0lOR0xFEAASDwoLRU5USVRMRU1FTlQQARIQCgxFTlRJVExFRF9LRVkQAiIoCglBbGdvcml0aG0SDwoLVU5FTkNSWVBURUQQABIKCgZBRVNDVFIQAUINCgtfY29udGVudF9pZEIWChRfY3J5cHRvX3BlcmlvZF9pbmRleEIUChJfcHJvdGVjdGlvbl9zY2hlbWVCGAoWX2NyeXB0b19wZXJpb2Rfc2Vjb25kc0IHCgVfdHlwZUIPCg1fa2V5X3NlcXVlbmNlQhAKDl92aWRlb19mZWF0dXJlQgwKCl9hbGdvcml0aG1CCwoJX3Byb3ZpZGVyQg0KC190cmFja190eXBlQgkKB19wb2xpY3lCEgoQX2dyb3VwZWRfbGljZW5zZSK4AgoKRmlsZUhhc2hlcxITCgZzaWduZXIYASABKAxIAIgBARI6CgpzaWduYXR1cmVzGAIgAygLMiYubGljZW5zZV9wcm90b2NvbC5GaWxlSGFzaGVzLlNpZ25hdHVyZRrNAQoJU2lnbmF0dXJlEhUKCGZpbGVuYW1lGAEgASgJSACIAQESGQoMdGVzdF9zaWduaW5nGAIgASgISAGIAQESFwoKU0hBNTEySGFzaBgDIAEoDEgCiAEBEhUKCG1haW5fZXhlGAQgASgISAOIAQESFgoJc2lnbmF0dXJlGAUgASgMSASIAQFCCwoJX2ZpbGVuYW1lQg8KDV90ZXN0X3NpZ25pbmdCDQoLX1NIQTUxMkhhc2hCCwoJX21haW5fZXhlQgwKCl9zaWduYXR1cmVCCQoHX3NpZ25lcipUCgtMaWNlbnNlVHlwZRIaChZMSUNFTlNFVFlQRV9VTlZFUklGSUVEEAASDQoJU1RSRUFNSU5HEAESCwoHT0ZGTElORRACEg0KCUFVVE9NQVRJQxADKtkBChpQbGF0Zm9ybVZlcmlmaWNhdGlvblN0YXR1cxIXChNQTEFURk9STV9VTlZFUklGSUVEEAASFQoRUExBVEZPUk1fVEFNUEVSRUQQARIeChpQTEFURk9STV9TT0ZUV0FSRV9WRVJJRklFRBACEh4KGlBMQVRGT1JNX0hBUkRXQVJFX1ZFUklGSUVEEAMSHAoYUExBVEZPUk1fTk9fVkVSSUZJQ0FUSU9OEAQSLQopUExBVEZPUk1fU0VDVVJFX1NUT1JBR0VfU09GVFdBUkVfVkVSSUZJRUQQBSpcCg9Qcm90b2NvbFZlcnNpb24SFgoSVkVSU0lPTl9VTlZFUklGSUVEEAASDwoLVkVSU0lPTl8yXzAQFBIPCgtWRVJTSU9OXzJfMRAVEg8KC1ZFUlNJT05fMl8yEBYqhgEKEkhhc2hBbGdvcml0aG1Qcm90bxIeChpIQVNIX0FMR09SSVRITV9VTlNQRUNJRklFRBAAEhgKFEhBU0hfQUxHT1JJVEhNX1NIQV8xEAESGgoWSEFTSF9BTEdPUklUSE1fU0hBXzI1NhACEhoKFkhBU0hfQUxHT1JJVEhNX1NIQV8zODQQA2IGcHJvdG8z'
  );

/**
 * LicenseIdentification is propagated from LicenseRequest to License,
 * incrementing version with each iteration.
 *
 * @generated from message license_protocol.LicenseIdentification
 */
export type LicenseIdentification = Message<'license_protocol.LicenseIdentification'> & {
  /**
   * @generated from field: optional bytes request_id = 1;
   */
  requestId?: Uint8Array;

  /**
   * @generated from field: optional bytes session_id = 2;
   */
  sessionId?: Uint8Array;

  /**
   * @generated from field: optional bytes purchase_id = 3;
   */
  purchaseId?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.LicenseType type = 4;
   */
  type?: LicenseType;

  /**
   * @generated from field: optional int32 version = 5;
   */
  version?: number;

  /**
   * @generated from field: optional bytes provider_session_token = 6;
   */
  providerSessionToken?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseIdentification.
 * Use `create(LicenseIdentificationSchema)` to create a new message.
 */
export const LicenseIdentificationSchema: GenMessage<LicenseIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 0);

/**
 * @generated from message license_protocol.License
 */
export type License = Message<'license_protocol.License'> & {
  /**
   * @generated from field: optional license_protocol.LicenseIdentification id = 1;
   */
  id?: LicenseIdentification;

  /**
   * @generated from field: optional license_protocol.License.Policy policy = 2;
   */
  policy?: License_Policy;

  /**
   * @generated from field: repeated license_protocol.License.KeyContainer key = 3;
   */
  key: License_KeyContainer[];

  /**
   * Time of the request in seconds (UTC) as set in
   * LicenseRequest.request_time.  If this time is not set in the request,
   * the local time at the license service is used in this field.
   *
   * @generated from field: optional int64 license_start_time = 4;
   */
  licenseStartTime?: bigint;

  /**
   * @generated from field: optional bool remote_attestation_verified = 5;
   */
  remoteAttestationVerified?: boolean;

  /**
   * Client token generated by the content provider. Optional.
   *
   * @generated from field: optional bytes provider_client_token = 6;
   */
  providerClientToken?: Uint8Array;

  /**
   * 4cc code specifying the CENC protection scheme as defined in the CENC 3.0
   * specification. Propagated from Widevine PSSH box. Optional.
   *
   * @generated from field: optional uint32 protection_scheme = 7;
   */
  protectionScheme?: number;

  /**
   * 8 byte verification field "HDCPDATA" followed by unsigned 32 bit minimum
   * HDCP SRM version (whether the version is for HDCP1 SRM or HDCP2 SRM
   * depends on client max_hdcp_version).
   * Additional details can be found in Widevine Modular DRM Security
   * Integration Guide for CENC.
   *
   * @generated from field: optional bytes srm_requirement = 8;
   */
  srmRequirement?: Uint8Array;

  /**
   * If present this contains a signed SRM file (either HDCP1 SRM or HDCP2 SRM
   * depending on client max_hdcp_version) that should be installed on the
   * client device.
   *
   * @generated from field: optional bytes srm_update = 9;
   */
  srmUpdate?: Uint8Array;

  /**
   * Indicates the status of any type of platform verification performed by the
   * server.
   *
   * @generated from field: optional license_protocol.PlatformVerificationStatus platform_verification_status = 10;
   */
  platformVerificationStatus?: PlatformVerificationStatus;

  /**
   * IDs of the groups for which keys are delivered in this license, if any.
   *
   * @generated from field: repeated bytes group_ids = 11;
   */
  groupIds: Uint8Array[];
};

/**
 * Describes the message license_protocol.License.
 * Use `create(LicenseSchema)` to create a new message.
 */
export const LicenseSchema: GenMessage<License> = /*@__PURE__*/ messageDesc(file_license_protocol, 1);

/**
 * @generated from message license_protocol.License.Policy
 */
export type License_Policy = Message<'license_protocol.License.Policy'> & {
  /**
   * Indicates that playback of the content is allowed.
   *
   * @generated from field: optional bool can_play = 1;
   */
  canPlay?: boolean;

  /**
   * Indicates that the license may be persisted to non-volatile
   * storage for offline use.
   *
   * @generated from field: optional bool can_persist = 2;
   */
  canPersist?: boolean;

  /**
   * Indicates that renewal of this license is allowed.
   *
   * @generated from field: optional bool can_renew = 3;
   */
  canRenew?: boolean;

  /**
   * Indicates the rental window.
   *
   * @generated from field: optional int64 rental_duration_seconds = 4;
   */
  rentalDurationSeconds?: bigint;

  /**
   * Indicates the viewing window, once playback has begun.
   *
   * @generated from field: optional int64 playback_duration_seconds = 5;
   */
  playbackDurationSeconds?: bigint;

  /**
   * Indicates the time window for this specific license.
   *
   * @generated from field: optional int64 license_duration_seconds = 6;
   */
  licenseDurationSeconds?: bigint;

  /**
   * The window of time, in which playback is allowed to continue while
   * renewal is attempted, yet unsuccessful due to backend problems with
   * the license server.
   *
   * @generated from field: optional int64 renewal_recovery_duration_seconds = 7;
   */
  renewalRecoveryDurationSeconds?: bigint;

  /**
   * All renewal requests for this license shall be directed to the
   * specified URL.
   *
   * @generated from field: optional string renewal_server_url = 8;
   */
  renewalServerUrl?: string;

  /**
   * How many seconds after license_start_time, before renewal is first
   * attempted.
   *
   * @generated from field: optional int64 renewal_delay_seconds = 9;
   */
  renewalDelaySeconds?: bigint;

  /**
   * Specifies the delay in seconds between subsequent license
   * renewal requests, in case of failure.
   *
   * @generated from field: optional int64 renewal_retry_interval_seconds = 10;
   */
  renewalRetryIntervalSeconds?: bigint;

  /**
   * Indicates that the license shall be sent for renewal when usage is
   * started.
   *
   * @generated from field: optional bool renew_with_usage = 11;
   */
  renewWithUsage?: boolean;

  /**
   * Indicates to client that license renewal and release requests ought to
   * include ClientIdentification (client_id).
   *
   * @generated from field: optional bool always_include_client_id = 12;
   */
  alwaysIncludeClientId?: boolean;

  /**
   * Duration of grace period before playback_duration_seconds (short window)
   * goes into effect. Optional.
   *
   * @generated from field: optional int64 play_start_grace_period_seconds = 13;
   */
  playStartGracePeriodSeconds?: bigint;

  /**
   * Enables "soft enforcement" of playback_duration_seconds, letting the user
   * finish playback even if short window expires. Optional.
   *
   * @generated from field: optional bool soft_enforce_playback_duration = 14;
   */
  softEnforcePlaybackDuration?: boolean;

  /**
   * Enables "soft enforcement" of rental_duration_seconds. Initial playback
   * must always start before rental duration expires.  In order to allow
   * subsequent playbacks to start after the rental duration expires,
   * soft_enforce_playback_duration must be true. Otherwise, subsequent
   * playbacks will not be allowed once rental duration expires. Optional.
   *
   * @generated from field: optional bool soft_enforce_rental_duration = 15;
   */
  softEnforceRentalDuration?: boolean;
};

/**
 * Describes the message license_protocol.License.Policy.
 * Use `create(License_PolicySchema)` to create a new message.
 */
export const License_PolicySchema: GenMessage<License_Policy> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 0);

/**
 * @generated from message license_protocol.License.KeyContainer
 */
export type License_KeyContainer = Message<'license_protocol.License.KeyContainer'> & {
  /**
   * @generated from field: optional bytes id = 1;
   */
  id?: Uint8Array;

  /**
   * @generated from field: optional bytes iv = 2;
   */
  iv?: Uint8Array;

  /**
   * @generated from field: optional bytes key = 3;
   */
  key?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.KeyType type = 4;
   */
  type?: License_KeyContainer_KeyType;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.SecurityLevel level = 5;
   */
  level?: License_KeyContainer_SecurityLevel;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection required_protection = 6;
   */
  requiredProtection?: License_KeyContainer_OutputProtection;

  /**
   * NOTE: Use of requested_protection is not recommended as it is only
   * supported on a small number of platforms.
   *
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection requested_protection = 7;
   */
  requestedProtection?: License_KeyContainer_OutputProtection;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.KeyControl key_control = 8;
   */
  keyControl?: License_KeyContainer_KeyControl;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OperatorSessionKeyPermissions operator_session_key_permissions = 9;
   */
  operatorSessionKeyPermissions?: License_KeyContainer_OperatorSessionKeyPermissions;

  /**
   * Optional video resolution constraints. If the video resolution of the
   * content being decrypted/decoded falls within one of the specified ranges,
   * the optional required_protections may be applied. Otherwise an error will
   * be reported.
   * NOTE: Use of this feature is not recommended, as it is only supported on
   * a small number of platforms.
   *
   * @generated from field: repeated license_protocol.License.KeyContainer.VideoResolutionConstraint video_resolution_constraints = 10;
   */
  videoResolutionConstraints: License_KeyContainer_VideoResolutionConstraint[];

  /**
   * Optional flag to indicate the key must only be used if the client
   * supports anti rollback of the user table.  Content provider can query the
   * client capabilities to determine if the client support this feature.
   *
   * @generated from field: optional bool anti_rollback_usage_table = 11;
   */
  antiRollbackUsageTable?: boolean;

  /**
   * Optional not limited to commonly known track types such as SD, HD.
   * It can be some provider defined label to identify the track.
   *
   * @generated from field: optional string track_label = 12;
   */
  trackLabel?: string;
};

/**
 * Describes the message license_protocol.License.KeyContainer.
 * Use `create(License_KeyContainerSchema)` to create a new message.
 */
export const License_KeyContainerSchema: GenMessage<License_KeyContainer> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 1);

/**
 * @generated from message license_protocol.License.KeyContainer.KeyControl
 */
export type License_KeyContainer_KeyControl = Message<'license_protocol.License.KeyContainer.KeyControl'> & {
  /**
   * |key_control| is documented in:
   * Widevine Modular DRM Security Integration Guide for CENC
   * If present, the key control must be communicated to the secure
   * environment prior to any usage. This message is automatically generated
   * by the Widevine License Server SDK.
   *
   * @generated from field: optional bytes key_control_block = 1;
   */
  keyControlBlock?: Uint8Array;

  /**
   * @generated from field: optional bytes iv = 2;
   */
  iv?: Uint8Array;
};

/**
 * Describes the message license_protocol.License.KeyContainer.KeyControl.
 * Use `create(License_KeyContainer_KeyControlSchema)` to create a new message.
 */
export const License_KeyContainer_KeyControlSchema: GenMessage<License_KeyContainer_KeyControl> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 1, 0);

/**
 * @generated from message license_protocol.License.KeyContainer.OutputProtection
 */
export type License_KeyContainer_OutputProtection = Message<'license_protocol.License.KeyContainer.OutputProtection'> & {
  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.HDCP hdcp = 1;
   */
  hdcp?: License_KeyContainer_OutputProtection_HDCP;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.CGMS cgms_flags = 2;
   */
  cgmsFlags?: License_KeyContainer_OutputProtection_CGMS;

  /**
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule hdcp_srm_rule = 3;
   */
  hdcpSrmRule?: License_KeyContainer_OutputProtection_HdcpSrmRule;

  /**
   * Optional requirement to indicate analog output is not allowed.
   *
   * @generated from field: optional bool disable_analog_output = 4;
   */
  disableAnalogOutput?: boolean;

  /**
   * Optional requirement to indicate digital output is not allowed.
   *
   * @generated from field: optional bool disable_digital_output = 5;
   */
  disableDigitalOutput?: boolean;
};

/**
 * Describes the message license_protocol.License.KeyContainer.OutputProtection.
 * Use `create(License_KeyContainer_OutputProtectionSchema)` to create a new message.
 */
export const License_KeyContainer_OutputProtectionSchema: GenMessage<License_KeyContainer_OutputProtection> = /*@__PURE__*/ messageDesc(file_license_protocol, 1, 1, 1);

/**
 * Indicates whether HDCP is required on digital outputs, and which
 * version should be used.
 *
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.HDCP
 */
export enum License_KeyContainer_OutputProtection_HDCP {
  /**
   * @generated from enum value: HDCP_NONE = 0;
   */
  HDCP_NONE = 0,

  /**
   * @generated from enum value: HDCP_V1 = 1;
   */
  HDCP_V1 = 1,

  /**
   * @generated from enum value: HDCP_V2 = 2;
   */
  HDCP_V2 = 2,

  /**
   * @generated from enum value: HDCP_V2_1 = 3;
   */
  HDCP_V2_1 = 3,

  /**
   * @generated from enum value: HDCP_V2_2 = 4;
   */
  HDCP_V2_2 = 4,

  /**
   * @generated from enum value: HDCP_V2_3 = 5;
   */
  HDCP_V2_3 = 5,

  /**
   * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
   */
  HDCP_NO_DIGITAL_OUTPUT = 255
}

/**
 * Describes the enum license_protocol.License.KeyContainer.OutputProtection.HDCP.
 */
export const License_KeyContainer_OutputProtection_HDCPSchema: GenEnum<License_KeyContainer_OutputProtection_HDCP> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 1, 0);

/**
 * Indicate the CGMS setting to be inserted on analog output.
 *
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.CGMS
 */
export enum License_KeyContainer_OutputProtection_CGMS {
  /**
   * @generated from enum value: COPY_FREE = 0;
   */
  COPY_FREE = 0,

  /**
   * @generated from enum value: CGMS_NONE = 42;
   */
  CGMS_NONE = 42,

  /**
   * @generated from enum value: COPY_ONCE = 2;
   */
  COPY_ONCE = 2,

  /**
   * @generated from enum value: COPY_NEVER = 3;
   */
  COPY_NEVER = 3
}

/**
 * Describes the enum license_protocol.License.KeyContainer.OutputProtection.CGMS.
 */
export const License_KeyContainer_OutputProtection_CGMSSchema: GenEnum<License_KeyContainer_OutputProtection_CGMS> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 1, 1);

/**
 * @generated from enum license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule
 */
export enum License_KeyContainer_OutputProtection_HdcpSrmRule {
  /**
   * @generated from enum value: HDCP_SRM_RULE_NONE = 0;
   */
  HDCP_SRM_RULE_NONE = 0,

  /**
   * In 'required_protection', this means most current SRM is required.
   * Update the SRM on the device. If update cannot happen,
   * do not allow the key.
   * In 'requested_protection', this means most current SRM is requested.
   * Update the SRM on the device. If update cannot happen,
   * allow use of the key anyway.
   *
   * @generated from enum value: CURRENT_SRM = 1;
   */
  CURRENT_SRM = 1
}

/**
 * Describes the enum license_protocol.License.KeyContainer.OutputProtection.HdcpSrmRule.
 */
export const License_KeyContainer_OutputProtection_HdcpSrmRuleSchema: GenEnum<License_KeyContainer_OutputProtection_HdcpSrmRule> =
  /*@__PURE__*/
  enumDesc(file_license_protocol, 1, 1, 1, 2);

/**
 * @generated from message license_protocol.License.KeyContainer.VideoResolutionConstraint
 */
export type License_KeyContainer_VideoResolutionConstraint = Message<'license_protocol.License.KeyContainer.VideoResolutionConstraint'> & {
  /**
   * Minimum and maximum video resolutions in the range (height x width).
   *
   * @generated from field: optional uint32 min_resolution_pixels = 1;
   */
  minResolutionPixels?: number;

  /**
   * @generated from field: optional uint32 max_resolution_pixels = 2;
   */
  maxResolutionPixels?: number;

  /**
   * Optional output protection requirements for this range. If not
   * specified, the OutputProtection in the KeyContainer applies.
   *
   * @generated from field: optional license_protocol.License.KeyContainer.OutputProtection required_protection = 3;
   */
  requiredProtection?: License_KeyContainer_OutputProtection;
};

/**
 * Describes the message license_protocol.License.KeyContainer.VideoResolutionConstraint.
 * Use `create(License_KeyContainer_VideoResolutionConstraintSchema)` to create a new message.
 */
export const License_KeyContainer_VideoResolutionConstraintSchema: GenMessage<License_KeyContainer_VideoResolutionConstraint> =
  /*@__PURE__*/
  messageDesc(file_license_protocol, 1, 1, 2);

/**
 * @generated from message license_protocol.License.KeyContainer.OperatorSessionKeyPermissions
 */
export type License_KeyContainer_OperatorSessionKeyPermissions = Message<'license_protocol.License.KeyContainer.OperatorSessionKeyPermissions'> & {
  /**
   * Permissions/key usage flags for operator service keys
   * (type = OPERATOR_SESSION).
   *
   * @generated from field: optional bool allow_encrypt = 1;
   */
  allowEncrypt?: boolean;

  /**
   * @generated from field: optional bool allow_decrypt = 2;
   */
  allowDecrypt?: boolean;

  /**
   * @generated from field: optional bool allow_sign = 3;
   */
  allowSign?: boolean;

  /**
   * @generated from field: optional bool allow_signature_verify = 4;
   */
  allowSignatureVerify?: boolean;
};

/**
 * Describes the message license_protocol.License.KeyContainer.OperatorSessionKeyPermissions.
 * Use `create(License_KeyContainer_OperatorSessionKeyPermissionsSchema)` to create a new message.
 */
export const License_KeyContainer_OperatorSessionKeyPermissionsSchema: GenMessage<License_KeyContainer_OperatorSessionKeyPermissions> =
  /*@__PURE__*/
  messageDesc(file_license_protocol, 1, 1, 3);

/**
 * @generated from enum license_protocol.License.KeyContainer.KeyType
 */
export enum License_KeyContainer_KeyType {
  /**
   * @generated from enum value: KEYTYPE_UNVERIFIED = 0;
   */
  KEYTYPE_UNVERIFIED = 0,

  /**
   * Exactly one key of this type must appear.
   *
   * @generated from enum value: SIGNING = 1;
   */
  SIGNING = 1,

  /**
   * Content key.
   *
   * @generated from enum value: CONTENT = 2;
   */
  CONTENT = 2,

  /**
   * Key control block for license renewals. No key.
   *
   * @generated from enum value: KEY_CONTROL = 3;
   */
  KEY_CONTROL = 3,

  /**
   * wrapped keys for auxiliary crypto operations.
   *
   * @generated from enum value: OPERATOR_SESSION = 4;
   */
  OPERATOR_SESSION = 4,

  /**
   * Entitlement keys.
   *
   * @generated from enum value: ENTITLEMENT = 5;
   */
  ENTITLEMENT = 5,

  /**
   * Partner-specific content key.
   *
   * @generated from enum value: OEM_CONTENT = 6;
   */
  OEM_CONTENT = 6
}

/**
 * Describes the enum license_protocol.License.KeyContainer.KeyType.
 */
export const License_KeyContainer_KeyTypeSchema: GenEnum<License_KeyContainer_KeyType> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 0);

/**
 * The SecurityLevel enumeration allows the server to communicate the level
 * of robustness required by the client, in order to use the key.
 *
 * @generated from enum license_protocol.License.KeyContainer.SecurityLevel
 */
export enum License_KeyContainer_SecurityLevel {
  /**
   * @generated from enum value: SECURITYLEVEL_UNVERIFIED = 0;
   */
  SECURITYLEVEL_UNVERIFIED = 0,

  /**
   * Software-based whitebox crypto is required.
   *
   * @generated from enum value: SW_SECURE_CRYPTO = 1;
   */
  SW_SECURE_CRYPTO = 1,

  /**
   * Software crypto and an obfuscated decoder is required.
   *
   * @generated from enum value: SW_SECURE_DECODE = 2;
   */
  SW_SECURE_DECODE = 2,

  /**
   * The key material and crypto operations must be performed within a
   * hardware backed trusted execution environment.
   *
   * @generated from enum value: HW_SECURE_CRYPTO = 3;
   */
  HW_SECURE_CRYPTO = 3,

  /**
   * The crypto and decoding of content must be performed within a hardware
   * backed trusted execution environment.
   *
   * @generated from enum value: HW_SECURE_DECODE = 4;
   */
  HW_SECURE_DECODE = 4,

  /**
   * The crypto, decoding and all handling of the media (compressed and
   * uncompressed) must be handled within a hardware backed trusted
   * execution environment.
   *
   * @generated from enum value: HW_SECURE_ALL = 5;
   */
  HW_SECURE_ALL = 5
}

/**
 * Describes the enum license_protocol.License.KeyContainer.SecurityLevel.
 */
export const License_KeyContainer_SecurityLevelSchema: GenEnum<License_KeyContainer_SecurityLevel> = /*@__PURE__*/ enumDesc(file_license_protocol, 1, 1, 1);

/**
 * @generated from message license_protocol.LicenseRequest
 */
export type LicenseRequest = Message<'license_protocol.LicenseRequest'> & {
  /**
   * The client_id provides information authenticating the calling device.  It
   * contains the Widevine keybox token that was installed on the device at the
   * factory.  This field or encrypted_client_id below is required for a valid
   * license request, but both should never be present in the same request.
   *
   * @generated from field: optional license_protocol.ClientIdentification client_id = 1;
   */
  clientId?: ClientIdentification;

  /**
   * @generated from field: optional license_protocol.LicenseRequest.ContentIdentification content_id = 2;
   */
  contentId?: LicenseRequest_ContentIdentification;

  /**
   * @generated from field: optional license_protocol.LicenseRequest.RequestType type = 3;
   */
  type?: LicenseRequest_RequestType;

  /**
   * Time of the request in seconds (UTC) as set by the client.
   *
   * @generated from field: optional int64 request_time = 4;
   */
  requestTime?: bigint;

  /**
   * Old-style decimal-encoded string key control nonce.
   *
   * @generated from field: optional bytes key_control_nonce_deprecated = 5;
   */
  keyControlNonceDeprecated?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.ProtocolVersion protocol_version = 6;
   */
  protocolVersion?: ProtocolVersion;

  /**
   * New-style uint32 key control nonce, please use instead of
   * key_control_nonce_deprecated.
   *
   * @generated from field: optional uint32 key_control_nonce = 7;
   */
  keyControlNonce?: number;

  /**
   * Encrypted ClientIdentification message, used for privacy purposes.
   *
   * @generated from field: optional license_protocol.EncryptedClientIdentification encrypted_client_id = 8;
   */
  encryptedClientId?: EncryptedClientIdentification;
};

/**
 * Describes the message license_protocol.LicenseRequest.
 * Use `create(LicenseRequestSchema)` to create a new message.
 */
export const LicenseRequestSchema: GenMessage<LicenseRequest> = /*@__PURE__*/ messageDesc(file_license_protocol, 2);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification
 */
export type LicenseRequest_ContentIdentification = Message<'license_protocol.LicenseRequest.ContentIdentification'> & {
  /**
   * @generated from oneof license_protocol.LicenseRequest.ContentIdentification.content_id_variant
   */
  contentIdVariant:
    | {
        /**
         * Exactly one of these must be present.
         *
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData widevine_pssh_data = 1;
         */
        value: LicenseRequest_ContentIdentification_WidevinePsshData;
        case: 'widevinePsshData';
      }
    | {
        /**
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.WebmKeyId webm_key_id = 2;
         */
        value: LicenseRequest_ContentIdentification_WebmKeyId;
        case: 'webmKeyId';
      }
    | {
        /**
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.ExistingLicense existing_license = 3;
         */
        value: LicenseRequest_ContentIdentification_ExistingLicense;
        case: 'existingLicense';
      }
    | {
        /**
         * @generated from field: license_protocol.LicenseRequest.ContentIdentification.InitData init_data = 4;
         */
        value: LicenseRequest_ContentIdentification_InitData;
        case: 'initData';
      }
    | { case: undefined; value?: undefined };
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.
 * Use `create(LicenseRequest_ContentIdentificationSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentificationSchema: GenMessage<LicenseRequest_ContentIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 2, 0);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData
 */
export type LicenseRequest_ContentIdentification_WidevinePsshData = Message<'license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData'> & {
  /**
   * @generated from field: repeated bytes pssh_data = 1;
   */
  psshData: Uint8Array[];

  /**
   * @generated from field: optional license_protocol.LicenseType license_type = 2;
   */
  licenseType?: LicenseType;

  /**
   * Opaque, client-specified.
   *
   * @generated from field: optional bytes request_id = 3;
   */
  requestId?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.WidevinePsshData.
 * Use `create(LicenseRequest_ContentIdentification_WidevinePsshDataSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_WidevinePsshDataSchema: GenMessage<LicenseRequest_ContentIdentification_WidevinePsshData> =
  /*@__PURE__*/
  messageDesc(file_license_protocol, 2, 0, 0);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.WebmKeyId
 */
export type LicenseRequest_ContentIdentification_WebmKeyId = Message<'license_protocol.LicenseRequest.ContentIdentification.WebmKeyId'> & {
  /**
   * @generated from field: optional bytes header = 1;
   */
  header?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.LicenseType license_type = 2;
   */
  licenseType?: LicenseType;

  /**
   * Opaque, client-specified.
   *
   * @generated from field: optional bytes request_id = 3;
   */
  requestId?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.WebmKeyId.
 * Use `create(LicenseRequest_ContentIdentification_WebmKeyIdSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_WebmKeyIdSchema: GenMessage<LicenseRequest_ContentIdentification_WebmKeyId> =
  /*@__PURE__*/
  messageDesc(file_license_protocol, 2, 0, 1);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.ExistingLicense
 */
export type LicenseRequest_ContentIdentification_ExistingLicense = Message<'license_protocol.LicenseRequest.ContentIdentification.ExistingLicense'> & {
  /**
   * @generated from field: optional license_protocol.LicenseIdentification license_id = 1;
   */
  licenseId?: LicenseIdentification;

  /**
   * @generated from field: optional int64 seconds_since_started = 2;
   */
  secondsSinceStarted?: bigint;

  /**
   * @generated from field: optional int64 seconds_since_last_played = 3;
   */
  secondsSinceLastPlayed?: bigint;

  /**
   * @generated from field: optional bytes session_usage_table_entry = 4;
   */
  sessionUsageTableEntry?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.ExistingLicense.
 * Use `create(LicenseRequest_ContentIdentification_ExistingLicenseSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_ExistingLicenseSchema: GenMessage<LicenseRequest_ContentIdentification_ExistingLicense> =
  /*@__PURE__*/
  messageDesc(file_license_protocol, 2, 0, 2);

/**
 * @generated from message license_protocol.LicenseRequest.ContentIdentification.InitData
 */
export type LicenseRequest_ContentIdentification_InitData = Message<'license_protocol.LicenseRequest.ContentIdentification.InitData'> & {
  /**
   * @generated from field: optional license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType init_data_type = 1;
   */
  initDataType?: LicenseRequest_ContentIdentification_InitData_InitDataType;

  /**
   * @generated from field: optional bytes init_data = 2;
   */
  initData?: Uint8Array;

  /**
   * @generated from field: optional license_protocol.LicenseType license_type = 3;
   */
  licenseType?: LicenseType;

  /**
   * @generated from field: optional bytes request_id = 4;
   */
  requestId?: Uint8Array;
};

/**
 * Describes the message license_protocol.LicenseRequest.ContentIdentification.InitData.
 * Use `create(LicenseRequest_ContentIdentification_InitDataSchema)` to create a new message.
 */
export const LicenseRequest_ContentIdentification_InitDataSchema: GenMessage<LicenseRequest_ContentIdentification_InitData> =
  /*@__PURE__*/
  messageDesc(file_license_protocol, 2, 0, 3);

/**
 * @generated from enum license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType
 */
export enum LicenseRequest_ContentIdentification_InitData_InitDataType {
  /**
   * @generated from enum value: INITDATATYPE_UNVERIFIED = 0;
   */
  INITDATATYPE_UNVERIFIED = 0,

  /**
   * @generated from enum value: CENC = 1;
   */
  CENC = 1,

  /**
   * @generated from enum value: WEBM = 2;
   */
  WEBM = 2
}

/**
 * Describes the enum license_protocol.LicenseRequest.ContentIdentification.InitData.InitDataType.
 */
export const LicenseRequest_ContentIdentification_InitData_InitDataTypeSchema: GenEnum<LicenseRequest_ContentIdentification_InitData_InitDataType> =
  /*@__PURE__*/
  enumDesc(file_license_protocol, 2, 0, 3, 0);

/**
 * @generated from enum license_protocol.LicenseRequest.RequestType
 */
export enum LicenseRequest_RequestType {
  /**
   * @generated from enum value: REQUESTTYPE_UNVERIFIED = 0;
   */
  REQUESTTYPE_UNVERIFIED = 0,

  /**
   * @generated from enum value: NEW = 1;
   */
  NEW = 1,

  /**
   * @generated from enum value: RENEWAL = 2;
   */
  RENEWAL = 2,

  /**
   * @generated from enum value: RELEASE = 3;
   */
  RELEASE = 3
}

/**
 * Describes the enum license_protocol.LicenseRequest.RequestType.
 */
export const LicenseRequest_RequestTypeSchema: GenEnum<LicenseRequest_RequestType> = /*@__PURE__*/ enumDesc(file_license_protocol, 2, 0);

/**
 * @generated from message license_protocol.MetricData
 */
export type MetricData = Message<'license_protocol.MetricData'> & {
  /**
   * 'stage' that is currently processing the SignedMessage.  Required.
   *
   * @generated from field: optional string stage_name = 1;
   */
  stageName?: string;

  /**
   * metric and associated value.
   *
   * @generated from field: repeated license_protocol.MetricData.TypeValue metric_data = 2;
   */
  metricData: MetricData_TypeValue[];
};

/**
 * Describes the message license_protocol.MetricData.
 * Use `create(MetricDataSchema)` to create a new message.
 */
export const MetricDataSchema: GenMessage<MetricData> = /*@__PURE__*/ messageDesc(file_license_protocol, 3);

/**
 * @generated from message license_protocol.MetricData.TypeValue
 */
export type MetricData_TypeValue = Message<'license_protocol.MetricData.TypeValue'> & {
  /**
   * @generated from field: optional license_protocol.MetricData.MetricType type = 1;
   */
  type?: MetricData_MetricType;

  /**
   * The value associated with 'type'.  For example if type == LATENCY, the
   * value would be the time in microseconds spent in this 'stage'.
   *
   * @generated from field: optional int64 value = 2;
   */
  value?: bigint;
};

/**
 * Describes the message license_protocol.MetricData.TypeValue.
 * Use `create(MetricData_TypeValueSchema)` to create a new message.
 */
export const MetricData_TypeValueSchema: GenMessage<MetricData_TypeValue> = /*@__PURE__*/ messageDesc(file_license_protocol, 3, 0);

/**
 * @generated from enum license_protocol.MetricData.MetricType
 */
export enum MetricData_MetricType {
  /**
   * @generated from enum value: METRICTYPE_UNVERIFIED = 0;
   */
  METRICTYPE_UNVERIFIED = 0,

  /**
   * The time spent in the 'stage', specified in microseconds.
   *
   * @generated from enum value: LATENCY = 1;
   */
  LATENCY = 1,

  /**
   * The UNIX epoch timestamp at which the 'stage' was first accessed in
   * microseconds.
   *
   * @generated from enum value: TIMESTAMP = 2;
   */
  TIMESTAMP = 2
}

/**
 * Describes the enum license_protocol.MetricData.MetricType.
 */
export const MetricData_MetricTypeSchema: GenEnum<MetricData_MetricType> = /*@__PURE__*/ enumDesc(file_license_protocol, 3, 0);

/**
 * @generated from message license_protocol.VersionInfo
 */
export type VersionInfo = Message<'license_protocol.VersionInfo'> & {
  /**
   * License SDK version reported by the Widevine License SDK. This field
   * is populated automatically by the SDK.
   *
   * @generated from field: optional string license_sdk_version = 1;
   */
  licenseSdkVersion?: string;

  /**
   * Version of the service hosting the license SDK. This field is optional.
   * It may be provided by the hosting service.
   *
   * @generated from field: optional string license_service_version = 2;
   */
  licenseServiceVersion?: string;
};

/**
 * Describes the message license_protocol.VersionInfo.
 * Use `create(VersionInfoSchema)` to create a new message.
 */
export const VersionInfoSchema: GenMessage<VersionInfo> = /*@__PURE__*/ messageDesc(file_license_protocol, 4);

/**
 * @generated from message license_protocol.SignedMessage
 */
export type SignedMessage = Message<'license_protocol.SignedMessage'> & {
  /**
   * @generated from field: optional license_protocol.SignedMessage.MessageType type = 1;
   */
  type?: SignedMessage_MessageType;

  /**
   * @generated from field: optional bytes msg = 2;
   */
  msg?: Uint8Array;

  /**
   * Required field that contains the signature of the bytes of msg.
   * For license requests, the signing algorithm is determined by the
   * certificate contained in the request.
   * For license responses, the signing algorithm is HMAC with signing key based
   * on |session_key|.
   *
   * @generated from field: optional bytes signature = 3;
   */
  signature?: Uint8Array;

  /**
   * If populated, the contents of this field will be signaled by the
   * |session_key_type| type. If the |session_key_type| is WRAPPED_AES_KEY the
   * key is the bytes of an encrypted AES key. If the |session_key_type| is
   * EPHERMERAL_ECC_PUBLIC_KEY the field contains the bytes of an RFC5208 ASN1
   * serialized ECC public key.
   *
   * @generated from field: optional bytes session_key = 4;
   */
  sessionKey?: Uint8Array;

  /**
   * Remote attestation data which will be present in the initial license
   * request for ChromeOS client devices operating in verified mode. Remote
   * attestation challenge data is |msg| field above. Optional.
   *
   * @generated from field: optional bytes remote_attestation = 5;
   */
  remoteAttestation?: Uint8Array;

  /**
   * @generated from field: repeated license_protocol.MetricData metric_data = 6;
   */
  metricData: MetricData[];

  /**
   * Version information from the SDK and license service. This information is
   * provided in the license response.
   *
   * @generated from field: optional license_protocol.VersionInfo service_version_info = 7;
   */
  serviceVersionInfo?: VersionInfo;

  /**
   * Optional field that contains the algorithm type used to generate the
   * session_key and signature in a LICENSE message.
   *
   * @generated from field: optional license_protocol.SignedMessage.SessionKeyType session_key_type = 8;
   */
  sessionKeyType?: SignedMessage_SessionKeyType;

  /**
   * The core message is the simple serialization of fields used by OEMCrypto.
   * This field was introduced in OEMCrypto API v16.
   *
   * @generated from field: optional bytes oemcrypto_core_message = 9;
   */
  oemcryptoCoreMessage?: Uint8Array;
};

/**
 * Describes the message license_protocol.SignedMessage.
 * Use `create(SignedMessageSchema)` to create a new message.
 */
export const SignedMessageSchema: GenMessage<SignedMessage> = /*@__PURE__*/ messageDesc(file_license_protocol, 5);

/**
 * @generated from enum license_protocol.SignedMessage.MessageType
 */
export enum SignedMessage_MessageType {
  /**
   * @generated from enum value: MESSAGETYPE_UNVERIFIED = 0;
   */
  MESSAGETYPE_UNVERIFIED = 0,

  /**
   * @generated from enum value: LICENSE_REQUEST = 1;
   */
  LICENSE_REQUEST = 1,

  /**
   * @generated from enum value: LICENSE = 2;
   */
  LICENSE = 2,

  /**
   * @generated from enum value: ERROR_RESPONSE = 3;
   */
  ERROR_RESPONSE = 3,

  /**
   * @generated from enum value: SERVICE_CERTIFICATE_REQUEST = 4;
   */
  SERVICE_CERTIFICATE_REQUEST = 4,

  /**
   * @generated from enum value: SERVICE_CERTIFICATE = 5;
   */
  SERVICE_CERTIFICATE = 5,

  /**
   * @generated from enum value: SUB_LICENSE = 6;
   */
  SUB_LICENSE = 6,

  /**
   * @generated from enum value: CAS_LICENSE_REQUEST = 7;
   */
  CAS_LICENSE_REQUEST = 7,

  /**
   * @generated from enum value: CAS_LICENSE = 8;
   */
  CAS_LICENSE = 8,

  /**
   * @generated from enum value: EXTERNAL_LICENSE_REQUEST = 9;
   */
  EXTERNAL_LICENSE_REQUEST = 9,

  /**
   * @generated from enum value: EXTERNAL_LICENSE = 10;
   */
  EXTERNAL_LICENSE = 10
}

/**
 * Describes the enum license_protocol.SignedMessage.MessageType.
 */
export const SignedMessage_MessageTypeSchema: GenEnum<SignedMessage_MessageType> = /*@__PURE__*/ enumDesc(file_license_protocol, 5, 0);

/**
 * @generated from enum license_protocol.SignedMessage.SessionKeyType
 */
export enum SignedMessage_SessionKeyType {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: WRAPPED_AES_KEY = 1;
   */
  WRAPPED_AES_KEY = 1,

  /**
   * @generated from enum value: EPHERMERAL_ECC_PUBLIC_KEY = 2;
   */
  EPHERMERAL_ECC_PUBLIC_KEY = 2
}

/**
 * Describes the enum license_protocol.SignedMessage.SessionKeyType.
 */
export const SignedMessage_SessionKeyTypeSchema: GenEnum<SignedMessage_SessionKeyType> = /*@__PURE__*/ enumDesc(file_license_protocol, 5, 1);

/**
 * ClientIdentification message used to authenticate the client device.
 *
 * @generated from message license_protocol.ClientIdentification
 */
export type ClientIdentification = Message<'license_protocol.ClientIdentification'> & {
  /**
   * Type of factory-provisioned device root of trust. Optional.
   *
   * @generated from field: optional license_protocol.ClientIdentification.TokenType type = 1;
   */
  type?: ClientIdentification_TokenType;

  /**
   * Factory-provisioned device root of trust. Required.
   *
   * @generated from field: optional bytes token = 2;
   */
  token?: Uint8Array;

  /**
   * Optional client information name/value pairs.
   *
   * @generated from field: repeated license_protocol.ClientIdentification.NameValue client_info = 3;
   */
  clientInfo: ClientIdentification_NameValue[];

  /**
   * Client token generated by the content provider. Optional.
   *
   * @generated from field: optional bytes provider_client_token = 4;
   */
  providerClientToken?: Uint8Array;

  /**
   * Number of licenses received by the client to which the token above belongs.
   * Only present if client_token is specified.
   *
   * @generated from field: optional uint32 license_counter = 5;
   */
  licenseCounter?: number;

  /**
   * List of non-baseline client capabilities.
   *
   * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities client_capabilities = 6;
   */
  clientCapabilities?: ClientIdentification_ClientCapabilities;

  /**
   * Serialized VmpData message. Optional.
   *
   * @generated from field: optional bytes vmp_data = 7;
   */
  vmpData?: Uint8Array;

  /**
   * Optional field that may contain additional provisioning credentials.
   *
   * @generated from field: repeated license_protocol.ClientIdentification.ClientCredentials device_credentials = 8;
   */
  deviceCredentials: ClientIdentification_ClientCredentials[];
};

/**
 * Describes the message license_protocol.ClientIdentification.
 * Use `create(ClientIdentificationSchema)` to create a new message.
 */
export const ClientIdentificationSchema: GenMessage<ClientIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 6);

/**
 * @generated from message license_protocol.ClientIdentification.NameValue
 */
export type ClientIdentification_NameValue = Message<'license_protocol.ClientIdentification.NameValue'> & {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: optional string value = 2;
   */
  value?: string;
};

/**
 * Describes the message license_protocol.ClientIdentification.NameValue.
 * Use `create(ClientIdentification_NameValueSchema)` to create a new message.
 */
export const ClientIdentification_NameValueSchema: GenMessage<ClientIdentification_NameValue> = /*@__PURE__*/ messageDesc(file_license_protocol, 6, 0);

/**
 * Capabilities which not all clients may support. Used for the license
 * exchange protocol only.
 *
 * @generated from message license_protocol.ClientIdentification.ClientCapabilities
 */
export type ClientIdentification_ClientCapabilities = Message<'license_protocol.ClientIdentification.ClientCapabilities'> & {
  /**
   * @generated from field: optional bool client_token = 1;
   */
  clientToken?: boolean;

  /**
   * @generated from field: optional bool session_token = 2;
   */
  sessionToken?: boolean;

  /**
   * @generated from field: optional bool video_resolution_constraints = 3;
   */
  videoResolutionConstraints?: boolean;

  /**
   * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion max_hdcp_version = 4;
   */
  maxHdcpVersion?: ClientIdentification_ClientCapabilities_HdcpVersion;

  /**
   * @generated from field: optional uint32 oem_crypto_api_version = 5;
   */
  oemCryptoApiVersion?: number;

  /**
   * Client has hardware support for protecting the usage table, such as
   * storing the generation number in secure memory.  For Details, see:
   * Widevine Modular DRM Security Integration Guide for CENC
   *
   * @generated from field: optional bool anti_rollback_usage_table = 6;
   */
  antiRollbackUsageTable?: boolean;

  /**
   * The client shall report |srm_version| if available.
   *
   * @generated from field: optional uint32 srm_version = 7;
   */
  srmVersion?: number;

  /**
   * A device may have SRM data, and report a version, but may not be capable
   * of updating SRM data.
   *
   * @generated from field: optional bool can_update_srm = 8;
   */
  canUpdateSrm?: boolean;

  /**
   * @generated from field: repeated license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType supported_certificate_key_type = 9;
   */
  supportedCertificateKeyType: ClientIdentification_ClientCapabilities_CertificateKeyType[];

  /**
   * @generated from field: optional license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities analog_output_capabilities = 10;
   */
  analogOutputCapabilities?: ClientIdentification_ClientCapabilities_AnalogOutputCapabilities;

  /**
   * @generated from field: optional bool can_disable_analog_output = 11;
   */
  canDisableAnalogOutput?: boolean;

  /**
   * Clients can indicate a performance level supported by OEMCrypto.
   * This will allow applications and providers to choose an appropriate
   * quality of content to serve. Currently defined tiers are
   * 1 (low), 2 (medium) and 3 (high). Any other value indicates that
   * the resource rating is unavailable or reporting erroneous values
   * for that device. For details see,
   * Widevine Modular DRM Security Integration Guide for CENC
   *
   * @generated from field: optional uint32 resource_rating_tier = 12;
   */
  resourceRatingTier?: number;
};

/**
 * Describes the message license_protocol.ClientIdentification.ClientCapabilities.
 * Use `create(ClientIdentification_ClientCapabilitiesSchema)` to create a new message.
 */
export const ClientIdentification_ClientCapabilitiesSchema: GenMessage<ClientIdentification_ClientCapabilities> = /*@__PURE__*/ messageDesc(file_license_protocol, 6, 1);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion
 */
export enum ClientIdentification_ClientCapabilities_HdcpVersion {
  /**
   * @generated from enum value: HDCP_NONE = 0;
   */
  HDCP_NONE = 0,

  /**
   * @generated from enum value: HDCP_V1 = 1;
   */
  HDCP_V1 = 1,

  /**
   * @generated from enum value: HDCP_V2 = 2;
   */
  HDCP_V2 = 2,

  /**
   * @generated from enum value: HDCP_V2_1 = 3;
   */
  HDCP_V2_1 = 3,

  /**
   * @generated from enum value: HDCP_V2_2 = 4;
   */
  HDCP_V2_2 = 4,

  /**
   * @generated from enum value: HDCP_V2_3 = 5;
   */
  HDCP_V2_3 = 5,

  /**
   * @generated from enum value: HDCP_NO_DIGITAL_OUTPUT = 255;
   */
  HDCP_NO_DIGITAL_OUTPUT = 255
}

/**
 * Describes the enum license_protocol.ClientIdentification.ClientCapabilities.HdcpVersion.
 */
export const ClientIdentification_ClientCapabilities_HdcpVersionSchema: GenEnum<ClientIdentification_ClientCapabilities_HdcpVersion> =
  /*@__PURE__*/
  enumDesc(file_license_protocol, 6, 1, 0);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType
 */
export enum ClientIdentification_ClientCapabilities_CertificateKeyType {
  /**
   * @generated from enum value: RSA_2048 = 0;
   */
  RSA_2048 = 0,

  /**
   * @generated from enum value: RSA_3072 = 1;
   */
  RSA_3072 = 1,

  /**
   * @generated from enum value: ECC_SECP256R1 = 2;
   */
  ECC_SECP256R1 = 2,

  /**
   * @generated from enum value: ECC_SECP384R1 = 3;
   */
  ECC_SECP384R1 = 3,

  /**
   * @generated from enum value: ECC_SECP521R1 = 4;
   */
  ECC_SECP521R1 = 4
}

/**
 * Describes the enum license_protocol.ClientIdentification.ClientCapabilities.CertificateKeyType.
 */
export const ClientIdentification_ClientCapabilities_CertificateKeyTypeSchema: GenEnum<ClientIdentification_ClientCapabilities_CertificateKeyType> =
  /*@__PURE__*/
  enumDesc(file_license_protocol, 6, 1, 1);

/**
 * @generated from enum license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities
 */
export enum ClientIdentification_ClientCapabilities_AnalogOutputCapabilities {
  /**
   * @generated from enum value: ANALOG_OUTPUT_UNKNOWN = 0;
   */
  ANALOG_OUTPUT_UNKNOWN = 0,

  /**
   * @generated from enum value: ANALOG_OUTPUT_NONE = 1;
   */
  ANALOG_OUTPUT_NONE = 1,

  /**
   * @generated from enum value: ANALOG_OUTPUT_SUPPORTED = 2;
   */
  ANALOG_OUTPUT_SUPPORTED = 2,

  /**
   * @generated from enum value: ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3;
   */
  ANALOG_OUTPUT_SUPPORTS_CGMS_A = 3
}

/**
 * Describes the enum license_protocol.ClientIdentification.ClientCapabilities.AnalogOutputCapabilities.
 */
export const ClientIdentification_ClientCapabilities_AnalogOutputCapabilitiesSchema: GenEnum<ClientIdentification_ClientCapabilities_AnalogOutputCapabilities> =
  /*@__PURE__*/
  enumDesc(file_license_protocol, 6, 1, 2);

/**
 * @generated from message license_protocol.ClientIdentification.ClientCredentials
 */
export type ClientIdentification_ClientCredentials = Message<'license_protocol.ClientIdentification.ClientCredentials'> & {
  /**
   * @generated from field: optional license_protocol.ClientIdentification.TokenType type = 1;
   */
  type?: ClientIdentification_TokenType;

  /**
   * @generated from field: optional bytes token = 2;
   */
  token?: Uint8Array;
};

/**
 * Describes the message license_protocol.ClientIdentification.ClientCredentials.
 * Use `create(ClientIdentification_ClientCredentialsSchema)` to create a new message.
 */
export const ClientIdentification_ClientCredentialsSchema: GenMessage<ClientIdentification_ClientCredentials> = /*@__PURE__*/ messageDesc(file_license_protocol, 6, 2);

/**
 * @generated from enum license_protocol.ClientIdentification.TokenType
 */
export enum ClientIdentification_TokenType {
  /**
   * @generated from enum value: KEYBOX = 0;
   */
  KEYBOX = 0,

  /**
   * @generated from enum value: DRM_DEVICE_CERTIFICATE = 1;
   */
  DRM_DEVICE_CERTIFICATE = 1,

  /**
   * @generated from enum value: REMOTE_ATTESTATION_CERTIFICATE = 2;
   */
  REMOTE_ATTESTATION_CERTIFICATE = 2,

  /**
   * @generated from enum value: OEM_DEVICE_CERTIFICATE = 3;
   */
  OEM_DEVICE_CERTIFICATE = 3
}

/**
 * Describes the enum license_protocol.ClientIdentification.TokenType.
 */
export const ClientIdentification_TokenTypeSchema: GenEnum<ClientIdentification_TokenType> = /*@__PURE__*/ enumDesc(file_license_protocol, 6, 0);

/**
 * EncryptedClientIdentification message used to hold ClientIdentification
 * messages encrypted for privacy purposes.
 *
 * @generated from message license_protocol.EncryptedClientIdentification
 */
export type EncryptedClientIdentification = Message<'license_protocol.EncryptedClientIdentification'> & {
  /**
   * Provider ID for which the ClientIdentifcation is encrypted (owner of
   * service certificate).
   *
   * @generated from field: optional string provider_id = 1;
   */
  providerId?: string;

  /**
   * Serial number for the service certificate for which ClientIdentification is
   * encrypted.
   *
   * @generated from field: optional bytes service_certificate_serial_number = 2;
   */
  serviceCertificateSerialNumber?: Uint8Array;

  /**
   * Serialized ClientIdentification message, encrypted with the privacy key
   * using AES-128-CBC with PKCS#5 padding.
   *
   * @generated from field: optional bytes encrypted_client_id = 3;
   */
  encryptedClientId?: Uint8Array;

  /**
   * Initialization vector needed to decrypt encrypted_client_id.
   *
   * @generated from field: optional bytes encrypted_client_id_iv = 4;
   */
  encryptedClientIdIv?: Uint8Array;

  /**
   * AES-128 privacy key, encrypted with the service public key using RSA-OAEP.
   *
   * @generated from field: optional bytes encrypted_privacy_key = 5;
   */
  encryptedPrivacyKey?: Uint8Array;
};

/**
 * Describes the message license_protocol.EncryptedClientIdentification.
 * Use `create(EncryptedClientIdentificationSchema)` to create a new message.
 */
export const EncryptedClientIdentificationSchema: GenMessage<EncryptedClientIdentification> = /*@__PURE__*/ messageDesc(file_license_protocol, 7);

/**
 * DRM certificate definition for user devices, intermediate, service, and root
 * certificates.
 *
 * @generated from message license_protocol.DrmCertificate
 */
export type DrmCertificate = Message<'license_protocol.DrmCertificate'> & {
  /**
   * Type of certificate. Required.
   *
   * @generated from field: optional license_protocol.DrmCertificate.Type type = 1;
   */
  type?: DrmCertificate_Type;

  /**
   * 128-bit globally unique serial number of certificate.
   * Value is 0 for root certificate. Required.
   *
   * @generated from field: optional bytes serial_number = 2;
   */
  serialNumber?: Uint8Array;

  /**
   * POSIX time, in seconds, when the certificate was created. Required.
   *
   * @generated from field: optional uint32 creation_time_seconds = 3;
   */
  creationTimeSeconds?: number;

  /**
   * POSIX time, in seconds, when the certificate should expire. Value of zero
   * denotes indefinite expiry time. For more information on limited lifespan
   * DRM certificates see (go/limited-lifespan-drm-certificates).
   *
   * @generated from field: optional uint32 expiration_time_seconds = 12;
   */
  expirationTimeSeconds?: number;

  /**
   * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
   *
   * @generated from field: optional bytes public_key = 4;
   */
  publicKey?: Uint8Array;

  /**
   * Widevine system ID for the device. Required for intermediate and
   * user device certificates.
   *
   * @generated from field: optional uint32 system_id = 5;
   */
  systemId?: number;

  /**
   * Deprecated field, which used to indicate whether the device was a test
   * (non-production) device. The test_device field in ProvisionedDeviceInfo
   * below should be observed instead.
   *
   * @generated from field: optional bool test_device_deprecated = 6 [deprecated = true];
   * @deprecated
   */
  testDeviceDeprecated?: boolean;

  /**
   * Service identifier (web origin) for the provider which owns the
   * certificate. Required for service and provisioner certificates.
   *
   * @generated from field: optional string provider_id = 7;
   */
  providerId?: string;

  /**
   * This field is used only when type = SERVICE to specify which SDK uses
   * service certificate. This repeated field is treated as a set. A certificate
   * may be used for the specified service SDK if the appropriate ServiceType
   * is specified in this field.
   *
   * @generated from field: repeated license_protocol.DrmCertificate.ServiceType service_types = 8;
   */
  serviceTypes: DrmCertificate_ServiceType[];

  /**
   * Required. The algorithm field contains the curve used to create the
   * |public_key| if algorithm is one of the ECC types.
   * The |algorithm| is used for both to determine the if the certificate is ECC
   * or RSA. The |algorithm| also specifies the parameters that were used to
   * create |public_key| and are used to create an ephemeral session key.
   *
   * @generated from field: optional license_protocol.DrmCertificate.Algorithm algorithm = 9;
   */
  algorithm?: DrmCertificate_Algorithm;

  /**
   * Optional. May be present in DEVICE certificate types. This is the root
   * of trust identifier that holds an encrypted value that identifies the
   * keybox or other root of trust that was used to provision a DEVICE drm
   * certificate.
   *
   * @generated from field: optional bytes rot_id = 10;
   */
  rotId?: Uint8Array;

  /**
   * Optional. May be present in devices that explicitly support dual keys. When
   * present the |public_key| is used for verification of received license
   * request messages.
   *
   * @generated from field: optional license_protocol.DrmCertificate.EncryptionKey encryption_key = 11;
   */
  encryptionKey?: DrmCertificate_EncryptionKey;
};

/**
 * Describes the message license_protocol.DrmCertificate.
 * Use `create(DrmCertificateSchema)` to create a new message.
 */
export const DrmCertificateSchema: GenMessage<DrmCertificate> = /*@__PURE__*/ messageDesc(file_license_protocol, 8);

/**
 * @generated from message license_protocol.DrmCertificate.EncryptionKey
 */
export type DrmCertificate_EncryptionKey = Message<'license_protocol.DrmCertificate.EncryptionKey'> & {
  /**
   * Device public key. PKCS#1 ASN.1 DER-encoded. Required.
   *
   * @generated from field: optional bytes public_key = 1;
   */
  publicKey?: Uint8Array;

  /**
   * Required. The algorithm field contains the curve used to create the
   * |public_key| if algorithm is one of the ECC types.
   * The |algorithm| is used for both to determine the if the certificate is
   * ECC or RSA. The |algorithm| also specifies the parameters that were used
   * to create |public_key| and are used to create an ephemeral session key.
   *
   * @generated from field: optional license_protocol.DrmCertificate.Algorithm algorithm = 2;
   */
  algorithm?: DrmCertificate_Algorithm;
};

/**
 * Describes the message license_protocol.DrmCertificate.EncryptionKey.
 * Use `create(DrmCertificate_EncryptionKeySchema)` to create a new message.
 */
export const DrmCertificate_EncryptionKeySchema: GenMessage<DrmCertificate_EncryptionKey> = /*@__PURE__*/ messageDesc(file_license_protocol, 8, 0);

/**
 * @generated from enum license_protocol.DrmCertificate.Type
 */
export enum DrmCertificate_Type {
  /**
   * ProtoBestPractices: ignore.
   *
   * @generated from enum value: ROOT = 0;
   */
  ROOT = 0,

  /**
   * @generated from enum value: DEVICE_MODEL = 1;
   */
  DEVICE_MODEL = 1,

  /**
   * @generated from enum value: DEVICE = 2;
   */
  DEVICE = 2,

  /**
   * @generated from enum value: SERVICE = 3;
   */
  SERVICE = 3,

  /**
   * @generated from enum value: PROVISIONER = 4;
   */
  PROVISIONER = 4
}

/**
 * Describes the enum license_protocol.DrmCertificate.Type.
 */
export const DrmCertificate_TypeSchema: GenEnum<DrmCertificate_Type> = /*@__PURE__*/ enumDesc(file_license_protocol, 8, 0);

/**
 * @generated from enum license_protocol.DrmCertificate.ServiceType
 */
export enum DrmCertificate_ServiceType {
  /**
   * @generated from enum value: UNKNOWN_SERVICE_TYPE = 0;
   */
  UNKNOWN_SERVICE_TYPE = 0,

  /**
   * @generated from enum value: LICENSE_SERVER_SDK = 1;
   */
  LICENSE_SERVER_SDK = 1,

  /**
   * @generated from enum value: LICENSE_SERVER_PROXY_SDK = 2;
   */
  LICENSE_SERVER_PROXY_SDK = 2,

  /**
   * @generated from enum value: PROVISIONING_SDK = 3;
   */
  PROVISIONING_SDK = 3,

  /**
   * @generated from enum value: CAS_PROXY_SDK = 4;
   */
  CAS_PROXY_SDK = 4
}

/**
 * Describes the enum license_protocol.DrmCertificate.ServiceType.
 */
export const DrmCertificate_ServiceTypeSchema: GenEnum<DrmCertificate_ServiceType> = /*@__PURE__*/ enumDesc(file_license_protocol, 8, 1);

/**
 * @generated from enum license_protocol.DrmCertificate.Algorithm
 */
export enum DrmCertificate_Algorithm {
  /**
   * @generated from enum value: UNKNOWN_ALGORITHM = 0;
   */
  UNKNOWN_ALGORITHM = 0,

  /**
   * @generated from enum value: RSA = 1;
   */
  RSA = 1,

  /**
   * @generated from enum value: ECC_SECP256R1 = 2;
   */
  ECC_SECP256R1 = 2,

  /**
   * @generated from enum value: ECC_SECP384R1 = 3;
   */
  ECC_SECP384R1 = 3,

  /**
   * @generated from enum value: ECC_SECP521R1 = 4;
   */
  ECC_SECP521R1 = 4
}

/**
 * Describes the enum license_protocol.DrmCertificate.Algorithm.
 */
export const DrmCertificate_AlgorithmSchema: GenEnum<DrmCertificate_Algorithm> = /*@__PURE__*/ enumDesc(file_license_protocol, 8, 2);

/**
 * DrmCertificate signed by a higher (CA) DRM certificate.
 *
 * @generated from message license_protocol.SignedDrmCertificate
 */
export type SignedDrmCertificate = Message<'license_protocol.SignedDrmCertificate'> & {
  /**
   * Serialized certificate. Required.
   *
   * @generated from field: optional bytes drm_certificate = 1;
   */
  drmCertificate?: Uint8Array;

  /**
   * Signature of certificate. Signed with root or intermediate
   * certificate specified below. Required.
   *
   * @generated from field: optional bytes signature = 2;
   */
  signature?: Uint8Array;

  /**
   * SignedDrmCertificate used to sign this certificate.
   *
   * @generated from field: optional license_protocol.SignedDrmCertificate signer = 3;
   */
  signer?: SignedDrmCertificate;

  /**
   * Optional field that indicates the hash algorithm used in signature scheme.
   *
   * @generated from field: optional license_protocol.HashAlgorithmProto hash_algorithm = 4;
   */
  hashAlgorithm?: HashAlgorithmProto;
};

/**
 * Describes the message license_protocol.SignedDrmCertificate.
 * Use `create(SignedDrmCertificateSchema)` to create a new message.
 */
export const SignedDrmCertificateSchema: GenMessage<SignedDrmCertificate> = /*@__PURE__*/ messageDesc(file_license_protocol, 9);

/**
 * @generated from message license_protocol.WidevinePsshData
 */
export type WidevinePsshData = Message<'license_protocol.WidevinePsshData'> & {
  /**
   * Entitlement or content key IDs. Can onnly present in SINGLE or ENTITLEMENT
   * PSSHs. May be repeated to facilitate delivery of multiple keys in a
   * single license. Cannot be used in conjunction with content_id or
   * group_ids, which are the preferred mechanism.
   *
   * @generated from field: repeated bytes key_ids = 2;
   */
  keyIds: Uint8Array[];

  /**
   * Content identifier which may map to multiple entitlement or content key
   * IDs to facilitate the delivery of multiple keys in a single license.
   * Cannot be present in conjunction with key_ids, but if used must be in all
   * PSSHs.
   *
   * @generated from field: optional bytes content_id = 4;
   */
  contentId?: Uint8Array;

  /**
   * Crypto period index, for media using key rotation. Always corresponds to
   * The content key period. This means that if using entitlement licensing
   * the ENTITLED_KEY PSSHs will have sequential crypto_period_index's, whereas
   * the ENTITELEMENT PSSHs will have gaps in the sequence. Required if doing
   * key rotation.
   *
   * @generated from field: optional uint32 crypto_period_index = 7;
   */
  cryptoPeriodIndex?: number;

  /**
   * Protection scheme identifying the encryption algorithm. The protection
   * scheme is represented as a uint32 value. The uint32 contains 4 bytes each
   * representing a single ascii character in one of the 4CC protection scheme
   * values. To be deprecated in favor of signaling from content.
   * 'cenc' (AES-CTR) protection_scheme = 0x63656E63,
   * 'cbc1' (AES-CBC) protection_scheme = 0x63626331,
   * 'cens' (AES-CTR pattern encryption) protection_scheme = 0x63656E73,
   * 'cbcs' (AES-CBC pattern encryption) protection_scheme = 0x63626373.
   *
   * @generated from field: optional uint32 protection_scheme = 9;
   */
  protectionScheme?: number;

  /**
   * Optional. For media using key rotation, this represents the duration
   * of each crypto period in seconds.
   *
   * @generated from field: optional uint32 crypto_period_seconds = 10;
   */
  cryptoPeriodSeconds?: number;

  /**
   * Type of PSSH. Required if not SINGLE.
   *
   * @generated from field: optional license_protocol.WidevinePsshData.Type type = 11;
   */
  type?: WidevinePsshData_Type;

  /**
   * Key sequence for Widevine-managed keys. Optional.
   *
   * @generated from field: optional uint32 key_sequence = 12;
   */
  keySequence?: number;

  /**
   * Group identifiers for all groups to which the content belongs. This can
   * be used to deliver licenses to unlock multiple titles / channels.
   * Optional, and may only be present in ENTITLEMENT and ENTITLED_KEY PSSHs, and
   * not in conjunction with key_ids.
   *
   * @generated from field: repeated bytes group_ids = 13;
   */
  groupIds: Uint8Array[];

  /**
   * Copy/copies of the content key used to decrypt the media stream in which
   * the PSSH box is embedded, each wrapped with a different entitlement key.
   * May also contain sub-licenses to support devices with OEMCrypto 13 or
   * older. May be repeated if using group entitlement keys. Present only in
   * PSSHs of type ENTITLED_KEY.
   *
   * @generated from field: repeated license_protocol.WidevinePsshData.EntitledKey entitled_keys = 14;
   */
  entitledKeys: WidevinePsshData_EntitledKey[];

  /**
   * Video feature identifier, which is used in conjunction with |content_id|
   * to determine the set of keys to be returned in the license. Cannot be
   * present in conjunction with |key_ids|.
   * Current values are "HDR".
   *
   * @generated from field: optional string video_feature = 15;
   */
  videoFeature?: string;

  /**
   * @generated from field: optional license_protocol.WidevinePsshData.Algorithm algorithm = 1 [deprecated = true];
   * @deprecated
   */
  algorithm?: WidevinePsshData_Algorithm;

  /**
   * Content provider name.
   *
   * @generated from field: optional string provider = 3 [deprecated = true];
   * @deprecated
   */
  provider?: string;

  /**
   * Track type. Acceptable values are SD, HD and AUDIO. Used to
   * differentiate content keys used by an asset.
   *
   * @generated from field: optional string track_type = 5 [deprecated = true];
   * @deprecated
   */
  trackType?: string;

  /**
   * The name of a registered policy to be used for this asset.
   *
   * @generated from field: optional string policy = 6 [deprecated = true];
   * @deprecated
   */
  policy?: string;

  /**
   * Optional protected context for group content. The grouped_license is a
   * serialized SignedMessage.
   *
   * @generated from field: optional bytes grouped_license = 8 [deprecated = true];
   * @deprecated
   */
  groupedLicense?: Uint8Array;
};

/**
 * Describes the message license_protocol.WidevinePsshData.
 * Use `create(WidevinePsshDataSchema)` to create a new message.
 */
export const WidevinePsshDataSchema: GenMessage<WidevinePsshData> = /*@__PURE__*/ messageDesc(file_license_protocol, 10);

/**
 * @generated from message license_protocol.WidevinePsshData.EntitledKey
 */
export type WidevinePsshData_EntitledKey = Message<'license_protocol.WidevinePsshData.EntitledKey'> & {
  /**
   * ID of entitlement key used for wrapping |key|.
   *
   * @generated from field: optional bytes entitlement_key_id = 1;
   */
  entitlementKeyId?: Uint8Array;

  /**
   * ID of the entitled key.
   *
   * @generated from field: optional bytes key_id = 2;
   */
  keyId?: Uint8Array;

  /**
   * Wrapped key. Required.
   *
   * @generated from field: optional bytes key = 3;
   */
  key?: Uint8Array;

  /**
   * IV used for wrapping |key|. Required.
   *
   * @generated from field: optional bytes iv = 4;
   */
  iv?: Uint8Array;

  /**
   * Size of entitlement key used for wrapping |key|.
   *
   * @generated from field: optional uint32 entitlement_key_size_bytes = 5;
   */
  entitlementKeySizeBytes?: number;
};

/**
 * Describes the message license_protocol.WidevinePsshData.EntitledKey.
 * Use `create(WidevinePsshData_EntitledKeySchema)` to create a new message.
 */
export const WidevinePsshData_EntitledKeySchema: GenMessage<WidevinePsshData_EntitledKey> = /*@__PURE__*/ messageDesc(file_license_protocol, 10, 0);

/**
 * @generated from enum license_protocol.WidevinePsshData.Type
 */
export enum WidevinePsshData_Type {
  /**
   * Single PSSH to be used to retrieve content keys.
   *
   * @generated from enum value: SINGLE = 0;
   */
  SINGLE = 0,

  /**
   * Primary PSSH used to retrieve entitlement keys.
   *
   * @generated from enum value: ENTITLEMENT = 1;
   */
  ENTITLEMENT = 1,

  /**
   * Secondary PSSH containing entitled key(s).
   *
   * @generated from enum value: ENTITLED_KEY = 2;
   */
  ENTITLED_KEY = 2
}

/**
 * Describes the enum license_protocol.WidevinePsshData.Type.
 */
export const WidevinePsshData_TypeSchema: GenEnum<WidevinePsshData_Type> = /*@__PURE__*/ enumDesc(file_license_protocol, 10, 0);

/**
 * //////////////////////////  Deprecated Fields  ////////////////////////////
 *
 * @generated from enum license_protocol.WidevinePsshData.Algorithm
 */
export enum WidevinePsshData_Algorithm {
  /**
   * @generated from enum value: UNENCRYPTED = 0;
   */
  UNENCRYPTED = 0,

  /**
   * @generated from enum value: AESCTR = 1;
   */
  AESCTR = 1
}

/**
 * Describes the enum license_protocol.WidevinePsshData.Algorithm.
 */
export const WidevinePsshData_AlgorithmSchema: GenEnum<WidevinePsshData_Algorithm> = /*@__PURE__*/ enumDesc(file_license_protocol, 10, 1);

/**
 * File Hashes for Verified Media Path (VMP) support.
 *
 * @generated from message license_protocol.FileHashes
 */
export type FileHashes = Message<'license_protocol.FileHashes'> & {
  /**
   * @generated from field: optional bytes signer = 1;
   */
  signer?: Uint8Array;

  /**
   * @generated from field: repeated license_protocol.FileHashes.Signature signatures = 2;
   */
  signatures: FileHashes_Signature[];
};

/**
 * Describes the message license_protocol.FileHashes.
 * Use `create(FileHashesSchema)` to create a new message.
 */
export const FileHashesSchema: GenMessage<FileHashes> = /*@__PURE__*/ messageDesc(file_license_protocol, 11);

/**
 * @generated from message license_protocol.FileHashes.Signature
 */
export type FileHashes_Signature = Message<'license_protocol.FileHashes.Signature'> & {
  /**
   * @generated from field: optional string filename = 1;
   */
  filename?: string;

  /**
   * 0 - release, 1 - testing
   *
   * @generated from field: optional bool test_signing = 2;
   */
  testSigning?: boolean;

  /**
   * @generated from field: optional bytes SHA512Hash = 3;
   */
  SHA512Hash?: Uint8Array;

  /**
   * 0 for dlls, 1 for exe, this is field 3 in file
   *
   * @generated from field: optional bool main_exe = 4;
   */
  mainExe?: boolean;

  /**
   * @generated from field: optional bytes signature = 5;
   */
  signature?: Uint8Array;
};

/**
 * Describes the message license_protocol.FileHashes.Signature.
 * Use `create(FileHashes_SignatureSchema)` to create a new message.
 */
export const FileHashes_SignatureSchema: GenMessage<FileHashes_Signature> = /*@__PURE__*/ messageDesc(file_license_protocol, 11, 0);

/**
 * @generated from enum license_protocol.LicenseType
 */
export enum LicenseType {
  /**
   * @generated from enum value: LICENSETYPE_UNVERIFIED = 0;
   */
  LICENSETYPE_UNVERIFIED = 0,

  /**
   * @generated from enum value: STREAMING = 1;
   */
  STREAMING = 1,

  /**
   * @generated from enum value: OFFLINE = 2;
   */
  OFFLINE = 2,

  /**
   * License type decision is left to provider.
   *
   * @generated from enum value: AUTOMATIC = 3;
   */
  AUTOMATIC = 3
}

/**
 * Describes the enum license_protocol.LicenseType.
 */
export const LicenseTypeSchema: GenEnum<LicenseType> = /*@__PURE__*/ enumDesc(file_license_protocol, 0);

/**
 * @generated from enum license_protocol.PlatformVerificationStatus
 */
export enum PlatformVerificationStatus {
  /**
   * The platform is not verified.
   *
   * @generated from enum value: PLATFORM_UNVERIFIED = 0;
   */
  PLATFORM_UNVERIFIED = 0,

  /**
   * Tampering detected on the platform.
   *
   * @generated from enum value: PLATFORM_TAMPERED = 1;
   */
  PLATFORM_TAMPERED = 1,

  /**
   * The platform has been verified by means of software.
   *
   * @generated from enum value: PLATFORM_SOFTWARE_VERIFIED = 2;
   */
  PLATFORM_SOFTWARE_VERIFIED = 2,

  /**
   * The platform has been verified by means of hardware (e.g. secure boot).
   *
   * @generated from enum value: PLATFORM_HARDWARE_VERIFIED = 3;
   */
  PLATFORM_HARDWARE_VERIFIED = 3,

  /**
   * Platform verification was not performed.
   *
   * @generated from enum value: PLATFORM_NO_VERIFICATION = 4;
   */
  PLATFORM_NO_VERIFICATION = 4,

  /**
   * Platform and secure storage capability have been verified by means of
   * software.
   *
   * @generated from enum value: PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5;
   */
  PLATFORM_SECURE_STORAGE_SOFTWARE_VERIFIED = 5
}

/**
 * Describes the enum license_protocol.PlatformVerificationStatus.
 */
export const PlatformVerificationStatusSchema: GenEnum<PlatformVerificationStatus> = /*@__PURE__*/ enumDesc(file_license_protocol, 1);

/**
 * @generated from enum license_protocol.ProtocolVersion
 */
export enum ProtocolVersion {
  /**
   * @generated from enum value: VERSION_UNVERIFIED = 0;
   */
  VERSION_UNVERIFIED = 0,

  /**
   * @generated from enum value: VERSION_2_0 = 20;
   */
  VERSION_2_0 = 20,

  /**
   * @generated from enum value: VERSION_2_1 = 21;
   */
  VERSION_2_1 = 21,

  /**
   * @generated from enum value: VERSION_2_2 = 22;
   */
  VERSION_2_2 = 22
}

/**
 * Describes the enum license_protocol.ProtocolVersion.
 */
export const ProtocolVersionSchema: GenEnum<ProtocolVersion> = /*@__PURE__*/ enumDesc(file_license_protocol, 2);

/**
 * @generated from enum license_protocol.HashAlgorithmProto
 */
export enum HashAlgorithmProto {
  /**
   * Unspecified hash algorithm: SHA_256 shall be used for ECC based algorithms
   * and SHA_1 shall be used otherwise.
   *
   * @generated from enum value: HASH_ALGORITHM_UNSPECIFIED = 0;
   */
  HASH_ALGORITHM_UNSPECIFIED = 0,

  /**
   * @generated from enum value: HASH_ALGORITHM_SHA_1 = 1;
   */
  HASH_ALGORITHM_SHA_1 = 1,

  /**
   * @generated from enum value: HASH_ALGORITHM_SHA_256 = 2;
   */
  HASH_ALGORITHM_SHA_256 = 2,

  /**
   * @generated from enum value: HASH_ALGORITHM_SHA_384 = 3;
   */
  HASH_ALGORITHM_SHA_384 = 3
}

/**
 * Describes the enum license_protocol.HashAlgorithmProto.
 */
export const HashAlgorithmProtoSchema: GenEnum<HashAlgorithmProto> = /*@__PURE__*/ enumDesc(file_license_protocol, 3);
